<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ cssSelector: "code", languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padr√£o √© 1.21, vc pode remover essa configura√ß√£o se quiser deixar o padr√£o */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* Remove a margem interna de tags pre dentro de tabelas */
            margin: 0;
            padding: 0;
            text-align: left;
        }

        td:has(pre) {
            /* tags pre dentro de tabela s√£o alinhadas no topo √† esquerda */
            vertical-align: top;
        }

        table.align-left th,
        table.align-left td {
            /* alinha √† esquerda as c√©lulas da tabela */
            text-align: left !important;
        }

        /* inicia a lista de exerc√≠cios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* p√µe um numerador num item da lista de exerc√≠cios, desde que n√£o seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* p√µe uma barra vertical ao lado do item da lista de exerc√≠cios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de c√≥digo da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de c√≥digo da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }

        .info {
            border-left: 6px solid blue;
            padding-left: 1%;
        }
    </style>
</head>

<div id="8-strings-and-serialization">
    <h1>8 Strings e serializa√ß√£o</h1>
    <div id="strings">
        <h2>8.1 Strings</h2>
        <div id="string-manipulation">
            <h3>8.1.1 Manipula√ß√£o de strings</h3>

            <p>Strings s√£o colocadas entre aspas duplas ou simples. Se colocadas entre 3 aspas (duplas ou simples), podem vir em v√°rias linhas. Exemplos:</p>
            <pre><code>a = 'hello'
b = "world"
c = '''a multiple
line string'''
d = """More
multiple"""

print(a, b, c, d, sep='\n\n')</code></pre>
            <p>As classes <code>str</code>, <code>list</code>, <code>tuple</code> e <code>range</code> s√£o conhecidas como <b>sequ√™ncias</b>, que s√£o classes iter√°veis que compartilham das opera√ß√µes de indexa√ß√£o (com os colchetes).</p>
            <p>Considere as seguintes vari√°veis:</p>
            <pre><code>string1 = 'abacate'
string2 = 'abacaxi'</code></pre>
            <p>Strings s√£o como listas, onde cada caractere √© como se fosse um elemento da lista, que est√° em seu respectivo √≠ndice. No python podemos usar √≠ndices negativos para acessar elementos de tr√°s para frente, como veremos.</p>
            <p><img id="string-indexes" alt="√≠ndices de string"></p>

            <p>Eis as principais opera√ß√µes suportadas por strings:</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Opera√ß√£o</th>
                        <th>Exemplo</th>
                        <th>Explica√ß√£o</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Concatena√ß√£o</strong></td>
                        <td>
                            <pre><code>concatenated_string = string1 + string2 # abacateabacaxi</code></pre>
                        </td>
                        <td>Junta duas ou mais strings.</td>

                    </tr>
                    <tr>
                        <td><strong>Repeti√ß√£o</strong></td>
                        <td>
                            <pre><code>repeated_string = string1 * 3 # abacateabacateabacate</code></pre>
                        </td>
                        <td>Repete uma string determinadas vezes.</td>

                    </tr>
                    <tr>
                        <td><strong>Indexa√ß√£o</strong></td>
                        <td>
                            <pre><code>x = string1[4]  # a
y = string1[-4]  # c</code></pre>
                        </td>
                        <td>Acessa caracteres individuais da string. Se informar um √≠ndice negativo, acessa de tr√°s para frente, sendo que o √∫ltimo caractere come√ßa do √≠ndice -1.</td>
                    </tr>
                    <tr>
                        <td rowspan="7"><strong>Fatiamento</strong></td>
                        <td>
                            <pre><code>i, j, k = 1, 6, 2
sliced = string1[i:j:k]  # bct</code></pre>
                        </td>
                        <td>Extrai uma substring, come√ßando do √≠ndice <code>i</code>, indo at√© o √≠ndice <code>j-1</code>, pulando de <code>k</code> em <code>k</code> √≠ndices.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced2 = string1[1:4]  # bac</code></pre>
                        </td>
                        <td>Se omitido o pulo, tamb√©m denominado passo, o padr√£o √© de 1 em 1.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced3 = string1[:2]  # ab</code></pre>
                        </td>
                        <td>Se omitido o primeiro √≠ndice, o padr√£o √© come√ßar do 0.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced4 = string1[1::3]  # ba</code></pre>
                        </td>
                        <td>Se omitido o segundo √≠ndice, o padr√£o √© terminar no √∫ltimo √≠ndice.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced5 = string1[4:1]  # </code></pre>
                        </td>
                        <td>Se o primeiro √≠ndice for maior ou igual ao segundo √≠ndice, retorna uma string vazia.</td>
                    </tr>

                    <tr>
                        <td>
                            <pre><code>sliced6 = string1[-6:-2]  # baca
sliced7 = string1[2:-2]  # aca</code></pre>
                        </td>
                        <td>Os √≠ndices tamb√©m podem ser negativos.</td>

                    <tr>
                        <td>
                            <pre><code>sliced8 = string1[::-1]  # etacaba
sliced9 = string1[-2:1:-3]  # ta</code></pre>
                        </td>
                        <td>Se o pulo for negativo, os caracteres s√£o extra√≠dos de tr√°s para frente. No caso, o primeiro √≠ndice precisa ser maior que o segundo √≠ndice para n√£o retornar uma string vazia.</td>
                    <tr>
                        <td><strong>Contin√™ncia</strong></td>
                        <td>
                            <pre><code>result = 'aca' in string1  # True
result2 = 'caxi' in string1  # False</code></pre>
                        </td>
                        <td>Verifica se uma string est√° contida em outra.</td>

                    </tr>
                    <tr>
                        <td><strong>Igualdade</strong></td>
                        <td>
                            <pre><code>result3 = string1 != string2  # True
result4 = string1 == 'abacate'  # True</code></pre>
                        </td>
                        <td>Verifica se uma string √© igual ou diferente a outra string.</td>

                    </tr>
                    <tr>
                        <td><strong>Compara√ß√£o</strong></td>
                        <td>
                            <pre><code>result5 = string1 &lt; string2  # True
result6 = 'aba' > string2  # False
result7 = 'asa' &lt;= string1  # False
result8 = string1[:5] >= string2[:5]  # True</code></pre>
                        </td>
                        <td>Compara lexicograficamente duas strings.</td>

                    </tr>
                </tbody>
            </table>
            <p>Vejamos alguns dos <a href="https://docs.python.org/3/library/stdtypes.html#str">m√©todos de strings</a>. Vamos come√ßar pelos m√©todos que retornam booleano.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Explica√ß√£o</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.startswith(prefix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string come√ßa com <code>prefix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.startswith('foo')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.endswith(suffix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string termina com <code>suffix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.endswith('ar')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalnum()</code></pre>
                        </td>
                        <td>Verifica se a string cont√©m apenas caracteres alfanum√©ricos (letras ou n√∫meros).</td>
                        <td>
                            <pre><code>'abc123'.isalnum()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalpha()</code></pre>
                        </td>
                        <td>Verifica se a string cont√©m apenas caracteres alfab√©ticos (letras).</td>
                        <td>
                            <pre><code>'abc123'.isalpha()  # False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isnumeric()</code></pre>
                        </td>
                        <td>Verifica se a string cont√©m apenas caracteres num√©ricos. Observe que, no sistema Unicode, muitos caracteres s√£o considerados num√©ricos, como os algarismos romanos <code>'‚Ö† ‚Ö° ‚Ö¢ ‚Ö£ ‚Ö§ ‚Ö• ‚Ö¶ ‚Öß ‚Ö® ‚Ö©'</code> (N√£o confunda o caractere <code>X</code>, de c√≥digo <code>\u0058</code>, com o <code>‚Ö©</code>, de c√≥digo <code>\u2169</code>).
                            <p>Por algum motivo, os caracteres <code>.</code> (ponto-final) e <code>-</code> (negativo) n√£o s√£o considerados num√©ricos. Portanto, para saber se uma string √© um <i>float</i> ou n√∫mero negativo, podemos usar regex, como veremos mais para frente, ou pass√°-la √† fun√ß√£o <code>float</code>, que retorna o n√∫mero ou lan√ßa uma exce√ß√£o caso n√£o seja um n√∫mero v√°lido.</p>
                            <p>Al√©m do m√©todo <code>isnumeric</code>, o Python tamb√©m tem m√©todos similares <code>isdigit</code> e <code>isdecimal</code>. Voc√™ encontra <a href="https://stackoverflow.com/a/54912545/4072641">mais informa√ß√µes aqui</a>.</p>
                        </td>
                        <td>
                            <pre><code>'0‚ìµùüö‚ë∂‚íã‚Öö‚Ö¶‚Ö∑Ÿ©'.isnumeric()  # True
'3.14'.isnumeric()  # False
'-5'.isnumeric()  # False

try:
    if float('-1.61'): True  # True
except:
    False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.islower()</code></pre>
                        </td>
                        <td>Verifica se as letras est√£o em min√∫sculo.</td>
                        <td>
                            <pre><code>'m1n√∫scul0'.islower()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isupper()</code></pre>
                        </td>
                        <td>Verifica se as letras est√£o em mai√∫sculo.</td>
                        <td>
                            <pre><code>'M41√ö5CUL0'.isupper()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isspace()</code></pre>
                        </td>
                        <td>Verifica se cont√©m apenas caracteres whitespaces (espa√ßos, quebras de linha, tabula√ß√µes...).</td>
                        <td>
                            <pre><code>' \t\n\r\v'.isspace()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.istitle()</code></pre>
                        </td>
                        <td>Verifica se o in√≠cio de cada palavra apenas √© mai√∫sculo.</td>
                        <td>
                            <pre><code>'Um Conto De Fadas'.istitle()  # True</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Agora, m√©todos que realizam alguma transforma√ß√£o na string. Observe que como uma string √© imut√°vel, as transforma√ß√µes na verdade s√£o a cria√ß√£o de uma nova string.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Explica√ß√£o</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.center(width[, fillchar])</code></pre>
                        </td>
                        <td>Centraliza a string entre caracteres <code>fillchar</code>, ocupando <code>width</code> caracteres. Se n√£o informar <code>fillchar</code>, o padr√£o √© espa√ßo.</td>
                        <td>
                            <pre><code>'oi'.center(10)  # '    oi    '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.ljust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string √† esquerda, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se n√£o informar <code>fillchar</code>, o padr√£o √© espa√ßo.</td>
                        <td>
                            <pre><code>'oi'.ljust(10)  # 'oi        '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rjust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string √† direita, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se n√£o informar <code>fillchar</code>, o padr√£o √© espa√ßo.</td>
                        <td>
                            <pre><code>'oi'.rjust(10)  # '        oi'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.replace(old, new[, count])</code></pre>
                        </td>
                        <td>Substitui todas as ocorr√™ncias de <code>old</code> por <code>new</code>, at√© <code>count</code> vezes. Se n√£o informar <code>count</code>, substitui todas as ocorr√™ncias.</td>
                        <td>
                            <pre><code>'fia, fio a fio, fino fio, frio a frio'.replace('fi', 'ti')  # 'tia, tio a tio, tino tio, frio a frio'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.strip([chars])</code></pre>
                        </td>
                        <td>Remove qualquer caractere inicial e final contido em <code>chars</code>. Se n√£o informado, remove whitespaces.</td>
                        <td>
                            <pre><code>'   spacious   '.strip()  # 'spacious'
'www.example.com'.strip('cmowz.')  # 'example'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.capitalize()</code></pre>
                        </td>
                        <td>Deixa apenas a primeira letra mai√∫scula.</td>
                        <td>
                            <pre><code>'foO BaR'.capitalize()  # Foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.lower()</code></pre>
                        </td>
                        <td>Converte todas as letras para min√∫sculo.</td>
                        <td>
                            <pre><code>'foO BaR'.lower  # foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.upper()</code></pre>
                        </td>
                        <td>Converte todas as letras para min√∫sculo.</td>
                        <td>
                            <pre><code>'foO BaR'.upper()  # FOO BAR</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.swapcase()</code></pre>
                        </td>
                        <td>Alterna as letras entre mai√∫sculo e min√∫sculo.</td>
                        <td>
                            <pre><code>'foO BaR'.swapcase()  # FOo bAr</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.title()</code></pre>
                        </td>
                        <td>Deixa mai√∫scula apenas a primeira letra de cada palavra.</td>
                        <td>
                            <pre><code>'foO BaR'.title()  # Foo Bar</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Tamb√©m temos m√©todos que realizam consultas em strings e retornam √≠ndices.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Explica√ß√£o</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.count(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Conta quantas vezes <code>sub</code> ocorre na string, come√ßando de <code>start</code>, indo at√© <code>end</code>
                        <td>
                            <pre><code>'fomos herois'.count('o')  # 3</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.find(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao operador <code>in</code>, mas retorna o √≠ndice onde encontrou a primeira ocorr√™ncia, ou <code>-1</code> caso n√£o ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.find('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.index(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao m√©todo <code>find</code>, mas lan√ßa uma exce√ß√£o caso n√£o ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.index('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rfind(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao m√©todo <code>find</code>, mas retorna o √≠ndice onde encontrou a √∫ltima ocorr√™ncia (r de <i>reverse</i>).</td>
                        <td>
                            <pre><code>'foo bar baz'.rfind('ba')  # 8</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rindex(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao m√©todo <code>rfind</code>, mas lan√ßa uma exce√ß√£o caso n√£o ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.rindex('ba')  # 8</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Por fim, temos m√©todos que trabalham com listas.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>M√©todo</th>
                        <th>Explica√ß√£o</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.join(iterable)</code></pre>
                        </td>
                        <td>Retorna uma string que √© a concatena√ß√£o das strings em <code>iterable</code>, usando a string fornecida como separador.</td>
                        <td>
                            <pre><code>', '.join(['foo', 'bar', 'baz', 'qux'])  # 'foo, bar, baz, qux'
':'.join('hello')  # 'h:e:l:l:o'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.split(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Divide a string em uma lista de substrings, usando <code>sep</code> como delimitador. Ocorrer√£o no m√°ximo <code>maxsplit</code> divis√µes, se informado.</td>
                        <td>
                            <pre><code>'foo bar\nbaz\tqux'.split()  # ['foo', 'bar', 'baz', 'qux']
'1,2,3'.split(',')  # ['1', '2', '3']
'1,2,3'.split(',', maxsplit=1)  # ['1', '2,3']
'1,2,,3,'.split(',')  # ['1', '2', '', '3', '']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rsplit(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Similar ao <code>split</code>, mas as divis√µes come√ßam da direita.</td>
                        <td>
                            <pre><code>'1,2,3'.split(',', maxsplit=1)  # ['1,2', '3']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.splitlines(keepends=False)</code></pre>
                        </td>
                        <td>Retorna uma lista com as linhas da string. As quebras de linha n√£o s√£o inclu√≠das na lista resultante, a menos que <code>keepends</code> seja fornecido e verdadeiro.</td>
                        <td>
                            <pre><code>'ab c\n\nde fg\rkl\r\n'.splitlines()  # ['ab c', '', 'de fg', 'kl']
'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)  # ['ab c\n', '\n', 'de fg\r', 'kl\r\n']</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="string-formatting">
            <h3>8.1.2 Formata√ß√£o de strings</h3>
            <p>Strings formatadas, conhecidas como <i>f-strings</i>, permitem que c√≥digo entre chaves seja interpretado dentro delas.</p>
            <pre><code>a, b = 1, 2
print(f"A soma de {a} e {b} √© {a+b}.")</code></pre>

            <div id="f-strings-can-contain-python-code">
                <h4>C√≥digos em strings formatadas</h4>
                <p>Praticamente qualquer c√≥digo Python que retorna uma string (ou um valor que pode ser convertido em uma string com a fun√ß√£o str()) pode ser executado dentro de uma f-string.</p>
                <pre><code>l = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]

print(f"alguns √≠mpares de fibonacci: {[a for a in l if a%2]}")
print(f"{l[4]} √© {'√≠mpar' if l[4]%2 else 'par'}")
print(f"o maior n√∫mero √© {max(l)}")</code></pre>
            </div>
            <div id="making-it-look-right">
                <h4>Formatando</h4>
                <p>Voc√™ pode saber mais sobre <a href="../alg/07 Caracteres.html#formatando-texto">formata√ß√£o de strings aqui</a>.</p>
            </div>
            <div id="custom-formatters">
                <h4>Formata√ß√£o personalizada</h4>
                Embora esses formatadores padr√£o se apliquem √† maioria dos objetos incorporados, tamb√©m √© poss√≠vel que outros objetos definam especificadores personalizados. Por exemplo, podemos usar especificadores de formato para objetos datetime:

                <pre><code>import datetime
print(f"{datetime.datetime.now():%d/%m/%Y %H:%M}")  # 24/04/2024 21:21</code></pre>

                <p>√â at√© poss√≠vel escrever formatadores personalizados para objetos que n√≥s mesmos criamos, mas isso est√° al√©m do escopo deste livro. Pesquise como sobrescrever m√©todo m√°gico <code>__format__</code> se precisar fazer isso em seu c√≥digo.</p>

                <p>A sintaxe de formata√ß√£o do Python √© bastante flex√≠vel, mas √© uma minilinguagem dif√≠cil de lembrar. O autor do livro usa todos os dias e ocasionalmente ainda precisa procurar conceitos esquecidos na documenta√ß√£o. Tamb√©m n√£o √© poderosa o suficiente para casos mais s√©rios, como a gera√ß√£o de p√°ginas da web. Existem v√°rias bibliotecas de modelagem (templating) de terceiros que voc√™ pode consultar se precisar fazer mais do que a formata√ß√£o b√°sica de algumas strings.</p>
            </div>
            <div id="the-format-method">
                <h4>O m√©todo <code>format</code></h4>
                <p>Antes do Python 3.6, que lan√ßou f-strings, voc√™ precisava usar o m√©todo <code>str.format</code>, que possui basicamente o mesmo uso:</p>
                <pre><code>>>> template = "abc {number:*^10d}"
>>> template.format(number=32)
'abc ****32****'
>>> template.format(number=84)
'abc ****84****'</code></pre>
                <p>Uma vantagem √© que voc√™ pode definir um template em uma vari√°vel e reutiliz√°-lo em outras partes simplesmente invocando o m√©todo <code>str.format</code>. A desvantagem √© que voc√™ s√≥ consegue passar valores ao <code>format</code>, mas n√£o pode executar c√≥digos como invoca√ß√µes de fun√ß√µes.</p>
            </div>
        </div>
        <div id="strings-are-unicode">
            <h3>8.1.3 Strings s√£o Unicode</h3>
            <p>Bytes representam 8 bits, geralmente descritos como inteiros entre 0 e 255, ou como hexadecimais entre 0 e FF.</p>
            <p>Qualquer tipo de dados √© armazenado como bytes, desde caracteres de strings at√© pixels de imagens.</p>
            <p>Para interpretar bytes como strings, precisamos de um sistema de codifica√ß√£o, que associa cada caractere do sistema de codifica√ß√£o a um ou mais bytes correspondentes. Por exemplo, a codifica√ß√£o mais consagrada, da qual muitas outras s√£o baseadas, √© a ASCII. Ela √© capaz de representar apenas 128 caracteres, dos quais apenas 95 s√£o caracteres imprim√≠veis, o que a limita bastante. Softwares modernos utilizam Unicode, que consegue representar milh√µes de caracteres, mas os primeiros 128 deles s√£o iguais √† ASCII.</p>
            <p>Mas n√£o existem apenas as codifica√ß√µes ASCII e Unicode. Se voc√™ tentar abrir um arquivo de texto codificado em outra codifica√ß√£o, pode ser que os caracteres sejam interpretados erroneamente.</p>
            <p>Em algumas situa√ß√µes vamos receber/enviar dados diretamente na forma de bytes, mesmo que representem texto. Nessas situa√ß√µes, precisamos saber converter entre bytes e caracteres.</p>
            <div id="converting-bytes-to-text">
                <h4>Convertendo bytes para texto</h4>
                <p>O Python possui o tipo de dados <code>bytes</code> para representar uma sequ√™ncia de bytes. Voc√™ instancia um objeto <code>bytes</code> como se fosse uma string, mas precedida por um <code>b</code> antes das aspas. Cada byte pode ser representado com o caractere de escape <code>\x</code> seguido por dois caracteres relativos ao seu n√∫mero hexadecimal.</p>
                <pre><code>>>> characters = b'\x63\x6c\x69\x63\x68\xe9'</code></pre>
                <p>Se imprimirmos essa vari√°vel, o Python interpretar√°, por padr√£o, essa sequ√™ncia de bytes como um texto ASCII:</p>
                <pre><code>>>> characters
b'clich\xe9'</code></pre>
                <p>Como ASCII vai at√© o n√∫mero 7F (127), n√£o h√° um caractere correspondente para o n√∫mero E9 (233). Mas podemos interpretar essa sequ√™ncia de bytes usando outra codifica√ß√£o. Como j√° sei de antem√£o que o byte E9 representa a letra '√©' na codifica√ß√£o ISO-8859-1, vamos us√°-la aqui:</p>
                <pre><code>>>> characters.decode("latin1")
'clich√©'
</code></pre>
                <p>Todo objeto <code>bytes</code> possui o m√©todo <code>decode</code> que interpreta (decodifica) os bytes em um sistema de codifica√ß√£o de caracteres passado como argumento. No caso, "latin-1" √© um apelido para ISO-8859-1.</p>
                <p>Se usarmos outro sistema de codifica√ß√£o para interpretar os bytes, pode ser que os caracteres sejam interpretados de outra forma, ou que uma exce√ß√£o seja lan√ßada, caso n√£o haja como interpretar algum caractere:</p>
                <pre><code>>>> characters.decode("cyrillic")
'clich—â'
>>> characters.decode("utf8")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: unexpected end of data</code></pre>
                <p>Nesse exemplo, a codifica√ß√£o "cyrillic" (ISO-8859-5) interpreta o byte E9 como '—â', j√° a codifica√ß√£o UTF-8 (Unicode) n√£o possui um caractere v√°lido para o byte E9, da√≠ a exce√ß√£o.</p>
            </div>
            <div id="converting-text-to-bytes">
                <h4>Convertendo texto para bytes</h4>
                <p>Converter de bytes para texto √© decodifica√ß√£o. E converter de texto para bytes √© codifica√ß√£o. Para codificar uma string em bytes, usamos o m√©todo <code>encode</code>.</p>
                <pre><code class="python-repl">>>> characters = "clich√©"
>>> characters.encode("utf8")
b'clich\xc3\xa9'
>>> characters.encode("latin1")
b'clich\xe9'
>>> characters.encode("cp437")
b'clich\x82'
>>> characters.encode("ascii")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)</code></pre>
            </div>
            <p>Observe que as codifica√ß√µes mais famosas usam o ASCII como um subconjunto, para compatibilidade. Mas come√ßam a divergir para caracteres al√©m do ASCII.</p>
            <p>Quando uma codifica√ß√£o n√£o consegue representar um caractere, por padr√£o, √© lan√ßada uma exce√ß√£o. Mas podemos mudar esse comportamento passando um segundo argumento ao m√©todo. As possibilidades para lidar com um caractere n√£o reconhecido s√£o:</p>
            <pre><code class="python-repl">>>> "clich√©".encode("ascii", 'strict')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)
>>> "clich√©".encode("ascii", 'replace')
b'clich?'
>>> "clich√©".encode("ascii", 'ignore')
b'clich'
>>> "clich√©".encode("ascii", 'xmlcharrefreplace')
b'clich&amp;#233;'</code></pre>
            <p><i>strict</i> √© a estrat√©gia padr√£o, se n√£o informada, e lan√ßa uma exce√ß√£o. <i>replace</i> substitui caracteres n√£o reconhecidos por interroga√ß√µes. <i>ignore</i> omite caracteres n√£o reconhecidos. E <i>xmlcharrefreplace</i> substitui o caractere n√£o reconhecido pela sua entidade XML.</p>

            <p>√â poss√≠vel invocar os m√©todos <code>str.encode</code> e <code>bytes.decode</code> sem informar a codifica√ß√£o. Nesse caso, ser√° usada a padr√£o do teu sistema operacional, que pode ser verificada com <code>sys.getedefaultencoding()</code>. Softwares modernos utilizam a codifica√ß√£o UTF-8, mas sistemas legados utilizavam mir√≠ades de codifica√ß√µes. Por isso, √© um bom h√°bito explicitamente informar a codifica√ß√£o, para que seu programa continue funcionando adequadamente em qualquer plataforma.</p>
        </div>
        <div id="mutable-byte-strings">
            <h3>8.1.4 Strings de byte mut√°veis</h3>
            <p>Objetos <code>str</code> e <code>bytes</code> s√£o imut√°veis. Para modificar esses objetos, na verdade instanciamos novos objetos<!-- (Removi essa parte pois n√£o necessariamente √© verdadeira, pois o Python possui otimiza√ß√µes para trabalhar com concatena√ß√£o de strings), que √© uma opera√ß√£o mais cara que simplesmente adicionar um item a uma lista, por exemplo. Isso pode ser incoveniente ao lidar com I/O, pois frequentemente √© necess√°rio fazer o buffer de bytes chegando ou saindo at√© que os dados estejam completos. Por exemplo, se estivermos recebendo dados de um socket, pode ser necess√°rio invocar <code>recv</code> v√°rias vezes antes de recebermos uma mensagem completa-->. Mas o Python tamb√©m possui o objeto <code>bytearray</code>, que funciona como um <code>bytes</code> mas possui muitas das opera√ß√µes e m√©todos de uma lista. A prop√≥sito, tanto <code>bytes</code> quanto <code>bytearray</code> possuem muitos dos m√©todos tamb√©m presentes em <code>str</code>, como <code>islower</code> ou <code>find</code>.</p>
            <pre><code class="python-repl">>>> b = bytearray(b"a\xe7\xe3o!")
>>> b.decode("latin1")
'a√ß√£o!'
>>> b[1] = 110
>>> b.decode("latin1")
'an√£o!'
>>> b[2:4] = b"el"
>>> b.decode("latin1")
'anel!'
>>> b[4] = "o"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object cannot be interpreted as an integer
>>> b[4] = ord("o")
>>> b
bytearray(b'anelo')</code></pre>
            <p>Ao inicializar um <code>bytearray</code>, podemos passar caracteres ASCII normalmente, que ser√£o mapeados para seus respectivos valores em bytes. Para outros caracteres, precisamos informar seu c√≥digo num√©rico, por exemplo, usando a sequ√™ncia de escape <code>\x</code>. A linha 4 modifica o byte do √≠ndice 1 para o valor 110, que em ASCII, √© a letra 'n'. A linha 7 modifica uma sequ√™ncia de bytes. Curiosamente, na linha 10, se tentar modificar apenas um √≠ndice passando uma string, d√° erro. Se voc√™ n√£o souber o c√≥digo ASCII de determinado caractere, pode invocar a fun√ß√£o <code>ord</code>, como na linha 14. Se tentar imprimir um objeto <code>bytes</code> ou <code>bytearray</code> sem decodific√°-lo, caracteres al√©m do ASCII n√£o ser√£o exibidos. Como na linha 15 n√£o h√° mais caracteres al√©m do ASCII, optei por imprimir o objeto sem decodific√°-lo.</p>

            <p>Com essas tr√™s op√ß√µes, pode ficar a d√∫vida de qual √© a mais apropriada. Como um princ√≠pio fundamental de programa√ß√£o, a legibilidade e a facilidade de manuseio devem ser priorizadas. Assim, se estiver lidando com texto, a escolha mais natural seria usar o tipo <code>str</code>. Se por outro lado for trabalhar com arquivos bin√°rios, melhor come√ßar com <code>bytes</code>. Se a mutabilidade de <code>bytearray</code> facilitar teu trabalho ou tornar teu c√≥digo mais leg√≠vel, ent√£o mude.</p>
        </div>
    </div>
    <div id="regular-expressions">
        <h2>8.2 Express√µes regulares</h2>
        <p>At√© o momento, a melhor forma de analisar (<i>parsing</i>) strings, buscando por padr√µes, √© atrav√©s de express√µes regulares. Apesar de regex (<i>regular expression</i>) n√£o ser orientada a objetos, no Python h√° v√°rios objetos para trabalhar com regex.</p>
        <div id="matching-patterns">
            <h3>8.2.1 Padr√µes de correspond√™ncia</h3>
            <p>Na linguagem regex, h√° os caracteres especiais, usados para formar padr√µes de textos, e os caracteres literais, que correspondem a si pr√≥prios. Vamos come√ßar com um exemplo de regex que busca por caracteres literais:</p>
            <pre><code>import re
print("achou 'hello'") if re.match("hello", "hello world") else print("n√£o achou 'hello'")
print("achou 'world'") if re.match("world", "hello world") else print("n√£o achou 'world'")</code></pre>
            <p>O primeiro argumento do m√©todo <code>match</code> √© o padr√£o de correspond√™ncia e o segundo argumento √© a string de busca. Se o padr√£o corresponder com a string, √© retornado um objeto <code>match</code>, com informa√ß√µes sobre a correspond√™ncia, sen√£o, √© retornado <code>None</code>.</p>
            <p>Observe que <code>match</code> verifica a correspond√™ncia no in√≠cio da string, e finaliza assim que o padr√£o foi encontrado.</p>
            <!-- 

^ in√≠cio da linha
$ final da linha

'helpo world' matches pattern 'hel.o world'
'hel o world' matches pattern 'hel.o world'
'helo world' does not match pattern 'hel.o world'

'hello world' matches pattern 'hel[lp]o world'
'helpo world' matches pattern 'hel[lp]o world'
'helPo world' does not match pattern 'hel[lp]o world'

'hello world' does not match pattern 'hello [a-z] world'
'hello b world' matches pattern 'hello [a-z] world'
'hello B world' matches pattern 'hello [a-zA-Z] world'
'hello 2 world' matches pattern 'hello [a-zA-Z0-9] world'

'hello' matches pattern 'hel*o'
'heo' matches pattern 'hel*o'
'helllllo' matches pattern 'hel*o'

'A string.' matches pattern '[A-Z][a-z]* [a-z]*\.'
'No .' matches pattern '[A-Z][a-z]* [a-z]*\.'
'' matches pattern '[a-z]*.*'

'0.4' matches pattern '\d+\.\d+'
'1.002' matches pattern '\d+\.\d+'
'1.' does not match pattern '\d+\.\d+'

'1%' matches pattern '\d?\d%'
'99%' matches pattern '\d?\d%'
'999%' does not match pattern '\d?\d%'

# escapando caracteres

'0.05' matches pattern '0\.[0-9][0-9]'
'005' does not match pattern '0\.[0-9][0-9]'
'0,05' does not match pattern '0\.[0-9][0-9]'

'abccc' matches pattern 'abc{3}'
'abccc' does not match pattern '(abc){3}'
'abcabcabc' matches pattern '(abc){3}'

Combined with complex patterns, this grouping feature greatly expands our patternmatching repertoire. Here's a regular expression that matches simple English sentences:
'Eat.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
'Eat more good food.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
'A good meal.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
             -->
            <div id="matching-a-selection-of-characters">
                <h4>Correspondendo uma sele√ß√£o de caracteres</h4>
            </div>
            <div id="escaping-characters">
                <h4>Caracteres de escape</h4>
            </div>
            <div id="matching-multiple-characters">
                <h4>Correspondendo m√∫ltiplos caracteres</h4>
            </div>
            <div id="grouping-patterns-together">
                <h4>Agrupando padr√µes</h4>
            </div>
        </div>
        <div id="getting-information-from-regular-expressions">
            <h3>8.2.2 Obtendo informa√ß√µes de express√µes regulares</h3>
            <p>Falar de captura de grupos com match.groups()[0]</p>
            The groups method returns a tuple of all the groups matched inside the pattern, which you can index to access a specific value. The groups are ordered from left to right. However, bear in mind that groups can be nested, meaning you can have one or more groups inside another group. In this case, the groups are returned in the order of their leftmost brackets, so the outermost group will be returned before its inner matching groups.

            In addition to the match function, the re module provides a couple of other useful functions, search and findall. The search function finds the first instance of a matching pattern, relaxing the restriction that the pattern should start at the first letter of the string. Note that you can get a similar effect by using match and putting a ^.* character at the front of the pattern to match any characters between the start of the string and the pattern you are looking for

            The findall function behaves similarly to search, except that it finds all non-overlapping instances of the matching pattern, not just the first one. Basically, it finds the first match, then it resets the search to the end of that matching string and finds the next one.

            Instead of returning a list of match objects, as you would expect, it returns a list of matching strings, or tuples. Sometimes it's strings, sometimes it's tuples. It's not a very good API at all! As with all bad APIs, you'll have to memorize the differences and not rely on intuition. The type of the return value depends on the number of bracketed groups inside the regular expression: If there are no groups in the pattern, re.findall will return a list of strings, where each value is a complete substring from the source string that matches the pattern If there is exactly one group in the pattern, re.findall will return a list of strings where each value is the contents of that group If there are multiple groups in the pattern, re.findall will return a list of tuples where each tuple contains a value from a matching group, in order

            When you are designing function calls in your own Python libraries, try to make the function always return a consistent data structure. It is often good to design functions that can take arbitrary inputs and process them, but the return value should not switch from a single value to a list, or a list of values to a list of tuples depending on the input. Let re.findall be a lesson!

            The examples in the following interactive session will hopefully clarify the differences:
            >>> import re
            >>> re.findall('a.', 'abacadefagah')
            ['ab', 'ac', 'ad', 'ag', 'ah']
            >>> re.findall('a(.)', 'abacadefagah')
            ['b', 'c', 'd', 'g', 'h']
            >>> re.findall('(a)(.)', 'abacadefagah')
            [('a', 'b'), ('a', 'c'), ('a', 'd'), ('a', 'g'), ('a', 'h')]
            >>> re.findall('((a)(.))', 'abacadefagah')
            [('ab', 'a', 'b'), ('ac', 'a', 'c'), ('ad', 'a', 'd'), ('ag', 'a', g'), ('ah', 'a','h')]

            <div id="making-repeated-regular-expressions-efficient">
                <h4>Usando regex eficientemente</h4>
                <p>Toda vez que voc√™ chama <code>match</code>, <code>search</code>, ou <code>findall</code>, o Python "compila" o padr√£o de busca em uma estrutura interna para pesquisa r√°pida de strings, o que leva tempo. Para maior efici√™ncia, se um padr√£o for reutilizado diversas vezes, √© melhor realizar essa compila√ß√£o apenas uma vez com o m√©todo <code>compile</code>.</p>
            </div>
            <div class="conclusao">
                <h4>Conclus√£o</h4>
                The key thing to understand is that regex is about knowing "what" you can do, not necessarily "how" to do it. 15 years regex experience, and I still have to look up rules in Google, and then use a regex tester. But, as long as you know what can be done, finding the how is trivial.
            </div>
        </div>
    </div>
    <div id="filesystem-paths">
        <h2>8.3 Caminhos de sistema de arquivos</h2>
    </div>
    <div id="serializing-objects">
        <h2>8.4 Serializando objetos</h2>
        <div id="customizing-pickles">
            <h3>8.4.1 Personalizando</h3>
        </div>
        <div id="serializing-web-objects">
            <h3>8.4.2 Serializando objetos web</h3>
        </div>
    </div>
    <div id="case-study">
        <h2>8.5 Estudo de caso</h2>
    </div>
    <div id="exercises">
        <h2>8.6 Exerc√≠cios</h2>
    </div>
</div>

<!-- exerc√≠cio que substitui uma substring por outra em uma string, pra verificar se o aluno sabe que uma string √© imut√°vel, substituindo a vari√°vel pelo novo valor. -->
<!-- n√£o esquecer de transformar a imagem em base64 ou svg -->
<!-- exerc√≠cios de regex
Is this string a valid URL?
What is the date and time of all warning messages in a log file?
Which users in /etc/passwd are in a given group?
What username and document were requested by the URL a visitor typed?
-->