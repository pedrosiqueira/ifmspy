<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ cssSelector: "code", languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padrão é 1.21, vc pode remover essa configuração se quiser deixar o padrão */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* Remove a margem interna de tags pre dentro de tabelas */
            margin: 0;
            padding: 0;
            text-align: left;
        }

        td:has(pre) {
            /* tags pre dentro de tabela são alinhadas no topo à esquerda */
            vertical-align: top;
        }

        table.align-left th,
        table.align-left td {
            /* alinha à esquerda as células da tabela */
            text-align: left !important;
        }

        /* inicia a lista de exercícios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* põe um numerador num item da lista de exercícios, desde que não seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* põe uma barra vertical ao lado do item da lista de exercícios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }

        .info {
            border-left: 6px solid blue;
            padding-left: 1%;
        }
    </style>
</head>

<div id="8-strings-and-serialization">
    <h1>8 Strings e serialização</h1>
    <div id="strings">
        <h2>8.1 Strings</h2>
        <div id="string-manipulation">
            <h3>8.1.1 Manipulação de strings</h3>

            <p>Strings são colocadas entre aspas duplas ou simples. Se colocadas entre 3 aspas (duplas ou simples), podem vir em várias linhas. Exemplos:</p>
            <pre><code>a = 'hello'
b = "world"
c = '''a multiple
line string'''
d = """More
multiple"""

print(a, b, c, d, sep='\n\n')</code></pre>
            <p>As classes <code>str</code>, <code>list</code>, <code>tuple</code> e <code>range</code> são conhecidas como <b>sequências</b>, que são classes iteráveis que compartilham das operações de indexação (com os colchetes).</p>
            <p>Considere as seguintes variáveis:</p>
            <pre><code>string1 = 'abacate'
string2 = 'abacaxi'</code></pre>
            <p>Strings são como listas, onde cada caractere é como se fosse um elemento da lista, que está em seu respectivo índice. No python podemos usar índices negativos para acessar elementos de trás para frente, como veremos.</p>
            <p><img id="string-indexes" alt="índices de string"></p>

            <p>Eis as principais operações suportadas por strings:</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Operação</th>
                        <th>Exemplo</th>
                        <th>Explicação</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Concatenação</strong></td>
                        <td>
                            <pre><code>concatenated_string = string1 + string2 # abacateabacaxi</code></pre>
                        </td>
                        <td>Junta duas ou mais strings.</td>

                    </tr>
                    <tr>
                        <td><strong>Repetição</strong></td>
                        <td>
                            <pre><code>repeated_string = string1 * 3 # abacateabacateabacate</code></pre>
                        </td>
                        <td>Repete uma string determinadas vezes.</td>

                    </tr>
                    <tr>
                        <td><strong>Indexação</strong></td>
                        <td>
                            <pre><code>x = string1[4]  # a
y = string1[-4]  # c</code></pre>
                        </td>
                        <td>Acessa caracteres individuais da string. Se informar um índice negativo, acessa de trás para frente, sendo que o último caractere começa do índice -1.</td>
                    </tr>
                    <tr>
                        <td rowspan="7"><strong>Fatiamento</strong></td>
                        <td>
                            <pre><code>i, j, k = 1, 6, 2
sliced = string1[i:j:k]  # bct</code></pre>
                        </td>
                        <td>Extrai uma substring, começando do índice <code>i</code>, indo até o índice <code>j-1</code>, pulando de <code>k</code> em <code>k</code> índices.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced2 = string1[1:4]  # bac</code></pre>
                        </td>
                        <td>Se omitido o pulo, também denominado passo, o padrão é de 1 em 1.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced3 = string1[:2]  # ab</code></pre>
                        </td>
                        <td>Se omitido o primeiro índice, o padrão é começar do 0.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced4 = string1[1::3]  # ba</code></pre>
                        </td>
                        <td>Se omitido o segundo índice, o padrão é terminar no último índice.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced5 = string1[4:1]  # </code></pre>
                        </td>
                        <td>Se o primeiro índice for maior ou igual ao segundo índice, retorna uma string vazia.</td>
                    </tr>

                    <tr>
                        <td>
                            <pre><code>sliced6 = string1[-6:-2]  # baca
sliced7 = string1[2:-2]  # aca</code></pre>
                        </td>
                        <td>Os índices também podem ser negativos.</td>

                    <tr>
                        <td>
                            <pre><code>sliced8 = string1[::-1]  # etacaba
sliced9 = string1[-2:1:-3]  # ta</code></pre>
                        </td>
                        <td>Se o pulo for negativo, os caracteres são extraídos de trás para frente. No caso, o primeiro índice precisa ser maior que o segundo índice para não retornar uma string vazia.</td>
                    <tr>
                        <td><strong>Continência</strong></td>
                        <td>
                            <pre><code>result = 'aca' in string1  # True
result2 = 'caxi' in string1  # False</code></pre>
                        </td>
                        <td>Verifica se uma string está contida em outra.</td>

                    </tr>
                    <tr>
                        <td><strong>Igualdade</strong></td>
                        <td>
                            <pre><code>result3 = string1 != string2  # True
result4 = string1 == 'abacate'  # True</code></pre>
                        </td>
                        <td>Verifica se uma string é igual ou diferente a outra string.</td>

                    </tr>
                    <tr>
                        <td><strong>Comparação</strong></td>
                        <td>
                            <pre><code>result5 = string1 &lt; string2  # True
result6 = 'aba' > string2  # False
result7 = 'asa' &lt;= string1  # False
result8 = string1[:5] >= string2[:5]  # True</code></pre>
                        </td>
                        <td>Compara lexicograficamente duas strings.</td>

                    </tr>
                </tbody>
            </table>
            <p>Vejamos alguns dos <a href="https://docs.python.org/3/library/stdtypes.html#str">métodos de strings</a>. Vamos começar pelos métodos que retornam booleano.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Explicação</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.startswith(prefix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string começa com <code>prefix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.startswith('foo')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.endswith(suffix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string termina com <code>suffix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.endswith('ar')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalnum()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres alfanuméricos (letras ou números).</td>
                        <td>
                            <pre><code>'abc123'.isalnum()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalpha()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres alfabéticos (letras).</td>
                        <td>
                            <pre><code>'abc123'.isalpha()  # False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isnumeric()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres numéricos. Observe que, no sistema Unicode, muitos caracteres são considerados numéricos, como os algarismos romanos <code>'Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ'</code> (Não confunda o caractere <code>X</code>, de código <code>\u0058</code>, com o <code>Ⅹ</code>, de código <code>\u2169</code>).
                            <p>Por algum motivo, os caracteres <code>.</code> (ponto-final) e <code>-</code> (negativo) não são considerados numéricos. Portanto, para saber se uma string é um <i>float</i> ou número negativo, podemos usar regex, como veremos mais para frente, ou passá-la à função <code>float</code>, que retorna o número ou lança uma exceção caso não seja um número válido.</p>
                            <p>Além do método <code>isnumeric</code>, o Python também tem métodos similares <code>isdigit</code> e <code>isdecimal</code>. Você encontra <a href="https://stackoverflow.com/a/54912545/4072641">mais informações aqui</a>.</p>
                        </td>
                        <td>
                            <pre><code>'0⓵𝟚⑶⒋⅚Ⅶⅷ٩'.isnumeric()  # True
'3.14'.isnumeric()  # False
'-5'.isnumeric()  # False

try:
    if float('-1.61'): True  # True
except:
    False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.islower()</code></pre>
                        </td>
                        <td>Verifica se as letras estão em minúsculo.</td>
                        <td>
                            <pre><code>'m1núscul0'.islower()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isupper()</code></pre>
                        </td>
                        <td>Verifica se as letras estão em maiúsculo.</td>
                        <td>
                            <pre><code>'M41Ú5CUL0'.isupper()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isspace()</code></pre>
                        </td>
                        <td>Verifica se contém apenas caracteres whitespaces (espaços, quebras de linha, tabulações...).</td>
                        <td>
                            <pre><code>' \t\n\r\v'.isspace()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.istitle()</code></pre>
                        </td>
                        <td>Verifica se o início de cada palavra apenas é maiúsculo.</td>
                        <td>
                            <pre><code>'Um Conto De Fadas'.istitle()  # True</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Agora, métodos que realizam alguma transformação na string. Observe que como uma string é imutável, as transformações na verdade são a criação de uma nova string.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Explicação</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.center(width[, fillchar])</code></pre>
                        </td>
                        <td>Centraliza a string entre caracteres <code>fillchar</code>, ocupando <code>width</code> caracteres. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.center(10)  # '    oi    '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.ljust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string à esquerda, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.ljust(10)  # 'oi        '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rjust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string à direita, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.rjust(10)  # '        oi'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.replace(old, new[, count])</code></pre>
                        </td>
                        <td>Substitui todas as ocorrências de <code>old</code> por <code>new</code>, até <code>count</code> vezes. Se não informar <code>count</code>, substitui todas as ocorrências.</td>
                        <td>
                            <pre><code>'fia, fio a fio, fino fio, frio a frio'.replace('fi', 'ti')  # 'tia, tio a tio, tino tio, frio a frio'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.strip([chars])</code></pre>
                        </td>
                        <td>Remove qualquer caractere inicial e final contido em <code>chars</code>. Se não informado, remove whitespaces.</td>
                        <td>
                            <pre><code>'   spacious   '.strip()  # 'spacious'
'www.example.com'.strip('cmowz.')  # 'example'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.capitalize()</code></pre>
                        </td>
                        <td>Deixa apenas a primeira letra maiúscula.</td>
                        <td>
                            <pre><code>'foO BaR'.capitalize()  # Foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.lower()</code></pre>
                        </td>
                        <td>Converte todas as letras para minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.lower  # foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.upper()</code></pre>
                        </td>
                        <td>Converte todas as letras para minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.upper()  # FOO BAR</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.swapcase()</code></pre>
                        </td>
                        <td>Alterna as letras entre maiúsculo e minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.swapcase()  # FOo bAr</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.title()</code></pre>
                        </td>
                        <td>Deixa maiúscula apenas a primeira letra de cada palavra.</td>
                        <td>
                            <pre><code>'foO BaR'.title()  # Foo Bar</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Também temos métodos que realizam consultas em strings e retornam índices.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Explicação</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.count(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Conta quantas vezes <code>sub</code> ocorre na string, começando de <code>start</code>, indo até <code>end</code>
                        <td>
                            <pre><code>'fomos herois'.count('o')  # 3</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.find(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao operador <code>in</code>, mas retorna o índice onde encontrou a primeira ocorrência, ou <code>-1</code> caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.find('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.index(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>find</code>, mas lança uma exceção caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.index('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rfind(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>find</code>, mas retorna o índice onde encontrou a última ocorrência (r de <i>reverse</i>).</td>
                        <td>
                            <pre><code>'foo bar baz'.rfind('ba')  # 8</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rindex(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>rfind</code>, mas lança uma exceção caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.rindex('ba')  # 8</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Por fim, temos métodos que trabalham com listas.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Explicação</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.join(iterable)</code></pre>
                        </td>
                        <td>Retorna uma string que é a concatenação das strings em <code>iterable</code>, usando a string fornecida como separador.</td>
                        <td>
                            <pre><code>', '.join(['foo', 'bar', 'baz', 'qux'])  # 'foo, bar, baz, qux'
':'.join('hello')  # 'h:e:l:l:o'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.split(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Divide a string em uma lista de substrings, usando <code>sep</code> como delimitador. Ocorrerão no máximo <code>maxsplit</code> divisões, se informado.</td>
                        <td>
                            <pre><code>'foo bar\nbaz\tqux'.split()  # ['foo', 'bar', 'baz', 'qux']
'1,2,3'.split(',')  # ['1', '2', '3']
'1,2,3'.split(',', maxsplit=1)  # ['1', '2,3']
'1,2,,3,'.split(',')  # ['1', '2', '', '3', '']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rsplit(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Similar ao <code>split</code>, mas as divisões começam da direita.</td>
                        <td>
                            <pre><code>'1,2,3'.split(',', maxsplit=1)  # ['1,2', '3']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.splitlines(keepends=False)</code></pre>
                        </td>
                        <td>Retorna uma lista com as linhas da string. As quebras de linha não são incluídas na lista resultante, a menos que <code>keepends</code> seja fornecido e verdadeiro.</td>
                        <td>
                            <pre><code>'ab c\n\nde fg\rkl\r\n'.splitlines()  # ['ab c', '', 'de fg', 'kl']
'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)  # ['ab c\n', '\n', 'de fg\r', 'kl\r\n']</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="string-formatting">
            <h3>8.1.2 Formatação de strings</h3>
            <p>Strings formatadas, conhecidas como <i>f-strings</i>, permitem que código entre chaves seja interpretado dentro delas.</p>
            <pre><code>a, b = 1, 2
print(f"A soma de {a} e {b} é {a+b}.")</code></pre>

            <div id="f-strings-can-contain-python-code">
                <h4>Códigos em strings formatadas</h4>
                <p>Praticamente qualquer código Python que retorna uma string (ou um valor que pode ser convertido em uma string com a função str()) pode ser executado dentro de uma f-string.</p>
                <pre><code>l = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]

print(f"alguns ímpares de fibonacci: {[a for a in l if a%2]}")
print(f"{l[4]} é {'ímpar' if l[4]%2 else 'par'}")
print(f"o maior número é {max(l)}")</code></pre>
            </div>
            <div id="making-it-look-right">
                <h4>Formatando</h4>
                <p>Você pode saber mais sobre <a href="../alg/07 Caracteres.html#formatando-texto">formatação de strings aqui</a>.</p>
            </div>
            <div id="custom-formatters">
                <h4>Formatação personalizada</h4>
                Embora esses formatadores padrão se apliquem à maioria dos objetos incorporados, também é possível que outros objetos definam especificadores personalizados. Por exemplo, podemos usar especificadores de formato para objetos datetime:

                <pre><code>import datetime
print(f"{datetime.datetime.now():%d/%m/%Y %H:%M}")  # 24/04/2024 21:21</code></pre>

                <p>É até possível escrever formatadores personalizados para objetos que nós mesmos criamos, mas isso está além do escopo deste livro. Pesquise como sobrescrever método mágico <code>__format__</code> se precisar fazer isso em seu código.</p>

                <p>A sintaxe de formatação do Python é bastante flexível, mas é uma minilinguagem difícil de lembrar. O autor do livro usa todos os dias e ocasionalmente ainda precisa procurar conceitos esquecidos na documentação. Também não é poderosa o suficiente para casos mais sérios, como a geração de páginas da web. Existem várias bibliotecas de modelagem (templating) de terceiros que você pode consultar se precisar fazer mais do que a formatação básica de algumas strings.</p>
            </div>
            <div id="the-format-method">
                <h4>O método <code>format</code></h4>
                <p>Antes do Python 3.6, que lançou f-strings, você precisava usar o método <code>str.format</code>, que possui basicamente o mesmo uso:</p>
                <pre><code>>>> template = "abc {number:*^10d}"
>>> template.format(number=32)
'abc ****32****'
>>> template.format(number=84)
'abc ****84****'</code></pre>
                <p>Uma vantagem é que você pode definir um template em uma variável e reutilizá-lo em outras partes simplesmente invocando o método <code>str.format</code>. A desvantagem é que você só consegue passar valores ao <code>format</code>, mas não pode executar códigos como invocações de funções.</p>
            </div>
        </div>
        <div id="strings-are-unicode">
            <h3>8.1.3 Strings são Unicode</h3>
            <p>Bytes representam 8 bits, geralmente descritos como inteiros entre 0 e 255, ou como hexadecimais entre 0 e FF.</p>
            <p>Qualquer tipo de dados é armazenado como bytes, desde caracteres de strings até pixels de imagens.</p>
            <p>Para interpretar bytes como strings, precisamos de um sistema de codificação, que associa cada caractere do sistema de codificação a um ou mais bytes correspondentes. Por exemplo, a codificação mais consagrada, da qual muitas outras são baseadas, é a ASCII. Ela é capaz de representar apenas 128 caracteres, dos quais apenas 95 são caracteres imprimíveis, o que a limita bastante. Softwares modernos utilizam Unicode, que consegue representar milhões de caracteres, mas os primeiros 128 deles são iguais à ASCII.</p>
            <p>Mas não existem apenas as codificações ASCII e Unicode. Se você tentar abrir um arquivo de texto codificado em outra codificação, pode ser que os caracteres sejam interpretados erroneamente.</p>
            <p>Em algumas situações vamos receber/enviar dados diretamente na forma de bytes, mesmo que representem texto. Nessas situações, precisamos saber converter entre bytes e caracteres.</p>
            <div id="converting-bytes-to-text">
                <h4>Convertendo bytes para texto</h4>
                <p>O Python possui o tipo de dados <code>bytes</code> para representar uma sequência de bytes. Você instancia um objeto <code>bytes</code> como se fosse uma string, mas precedida por um <code>b</code> antes das aspas. Cada byte pode ser representado com o caractere de escape <code>\x</code> seguido por dois caracteres relativos ao seu número hexadecimal.</p>
                <pre><code>>>> characters = b'\x63\x6c\x69\x63\x68\xe9'</code></pre>
                <p>Se imprimirmos essa variável, o Python interpretará, por padrão, essa sequência de bytes como um texto ASCII:</p>
                <pre><code>>>> characters
b'clich\xe9'</code></pre>
                <p>Como ASCII vai até o número 7F (127), não há um caractere correspondente para o número E9 (233). Mas podemos interpretar essa sequência de bytes usando outra codificação. Como já sei de antemão que o byte E9 representa a letra 'é' na codificação ISO-8859-1, vamos usá-la aqui:</p>
                <pre><code>>>> characters.decode("latin1")
'cliché'
</code></pre>
                <p>Todo objeto <code>bytes</code> possui o método <code>decode</code> que interpreta (decodifica) os bytes em um sistema de codificação de caracteres passado como argumento. No caso, "latin-1" é um apelido para ISO-8859-1.</p>
                <p>Se usarmos outro sistema de codificação para interpretar os bytes, pode ser que os caracteres sejam interpretados de outra forma, ou que uma exceção seja lançada, caso não haja como interpretar algum caractere:</p>
                <pre><code>>>> characters.decode("cyrillic")
'clichщ'
>>> characters.decode("utf8")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: unexpected end of data</code></pre>
                <p>Nesse exemplo, a codificação "cyrillic" (ISO-8859-5) interpreta o byte E9 como 'щ', já a codificação UTF-8 (Unicode) não possui um caractere válido para o byte E9, daí a exceção.</p>
            </div>
            <div id="converting-text-to-bytes">
                <h4>Convertendo texto para bytes</h4>
                <p>Converter de bytes para texto é decodificação. E converter de texto para bytes é codificação. Para codificar uma string em bytes, usamos o método <code>encode</code>.</p>
                <pre><code class="python-repl">>>> characters = "cliché"
>>> characters.encode("utf8")
b'clich\xc3\xa9'
>>> characters.encode("latin1")
b'clich\xe9'
>>> characters.encode("cp437")
b'clich\x82'
>>> characters.encode("ascii")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)</code></pre>
            </div>
            <p>Observe que as codificações mais famosas usam o ASCII como um subconjunto, para compatibilidade. Mas começam a divergir para caracteres além do ASCII.</p>
            <p>Quando uma codificação não consegue representar um caractere, por padrão, é lançada uma exceção. Mas podemos mudar esse comportamento passando um segundo argumento ao método. As possibilidades para lidar com um caractere não reconhecido são:</p>
            <pre><code class="python-repl">>>> "cliché".encode("ascii", 'strict')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)
>>> "cliché".encode("ascii", 'replace')
b'clich?'
>>> "cliché".encode("ascii", 'ignore')
b'clich'
>>> "cliché".encode("ascii", 'xmlcharrefreplace')
b'clich&amp;#233;'</code></pre>
            <p><i>strict</i> é a estratégia padrão, se não informada, e lança uma exceção. <i>replace</i> substitui caracteres não reconhecidos por interrogações. <i>ignore</i> omite caracteres não reconhecidos. E <i>xmlcharrefreplace</i> substitui o caractere não reconhecido pela sua entidade XML.</p>

            <p>É possível invocar os métodos <code>str.encode</code> e <code>bytes.decode</code> sem informar a codificação. Nesse caso, será usada a padrão do teu sistema operacional, que pode ser verificada com <code>sys.getedefaultencoding()</code>. Softwares modernos utilizam a codificação UTF-8, mas sistemas legados utilizavam miríades de codificações. Por isso, é um bom hábito explicitamente informar a codificação, para que seu programa continue funcionando adequadamente em qualquer plataforma.</p>
        </div>
        <div id="mutable-byte-strings">
            <h3>8.1.4 Strings de byte mutáveis</h3>
            <p>Objetos <code>str</code> e <code>bytes</code> são imutáveis. Para modificar esses objetos, na verdade instanciamos novos objetos<!-- (Removi essa parte pois não necessariamente é verdadeira, pois o Python possui otimizações para trabalhar com concatenação de strings), que é uma operação mais cara que simplesmente adicionar um item a uma lista, por exemplo. Isso pode ser incoveniente ao lidar com I/O, pois frequentemente é necessário fazer o buffer de bytes chegando ou saindo até que os dados estejam completos. Por exemplo, se estivermos recebendo dados de um socket, pode ser necessário invocar <code>recv</code> várias vezes antes de recebermos uma mensagem completa-->. Mas o Python também possui o objeto <code>bytearray</code>, que funciona como um <code>bytes</code> mas possui muitas das operações e métodos de uma lista. A propósito, tanto <code>bytes</code> quanto <code>bytearray</code> possuem muitos dos métodos também presentes em <code>str</code>, como <code>islower</code> ou <code>find</code>.</p>
            <pre><code class="python-repl">>>> b = bytearray(b"a\xe7\xe3o!")
>>> b.decode("latin1")
'ação!'
>>> b[1] = 110
>>> b.decode("latin1")
'anão!'
>>> b[2:4] = b"el"
>>> b.decode("latin1")
'anel!'
>>> b[4] = "o"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object cannot be interpreted as an integer
>>> b[4] = ord("o")
>>> b
bytearray(b'anelo')</code></pre>
            <p>Ao inicializar um <code>bytearray</code>, podemos passar caracteres ASCII normalmente, que serão mapeados para seus respectivos valores em bytes. Para outros caracteres, precisamos informar seu código numérico, por exemplo, usando a sequência de escape <code>\x</code>. A linha 4 modifica o byte do índice 1 para o valor 110, que em ASCII, é a letra 'n'. A linha 7 modifica uma sequência de bytes. Curiosamente, na linha 10, se tentar modificar apenas um índice passando uma string, dá erro. Se você não souber o código ASCII de determinado caractere, pode invocar a função <code>ord</code>, como na linha 14. Se tentar imprimir um objeto <code>bytes</code> ou <code>bytearray</code> sem decodificá-lo, caracteres além do ASCII não serão exibidos. Como na linha 15 não há mais caracteres além do ASCII, optei por imprimir o objeto sem decodificá-lo.</p>

            <p>Com essas três opções, pode ficar a dúvida de qual é a mais apropriada. Como um princípio fundamental de programação, a legibilidade e a facilidade de manuseio devem ser priorizadas. Assim, se estiver lidando com texto, a escolha mais natural seria usar o tipo <code>str</code>. Se por outro lado for trabalhar com arquivos binários, melhor começar com <code>bytes</code>. Se a mutabilidade de <code>bytearray</code> facilitar teu trabalho ou tornar teu código mais legível, então mude.</p>
        </div>
    </div>
    <div id="regular-expressions">
        <h2>8.2 Expressões regulares</h2>
        <p>Até o momento, a melhor forma de analisar (<i>parsing</i>) strings, buscando por padrões, é através de expressões regulares. Apesar de regex (<i>regular expression</i>) não ser orientada a objetos, no Python há vários objetos para trabalhar com regex.</p>
        <div id="matching-patterns">
            <h3>8.2.1 Padrões de correspondência</h3>
            <p>Na linguagem regex, há os caracteres especiais, usados para formar padrões de textos, e os caracteres literais, que correspondem a si próprios. Vamos começar com um exemplo de regex que busca por caracteres literais:</p>
            <pre><code>import re
print("achou 'hello'") if re.match("hello", "hello world") else print("não achou 'hello'")
print("achou 'world'") if re.match("world", "hello world") else print("não achou 'world'")</code></pre>
            <p>O primeiro argumento do método <code>match</code> é o padrão de correspondência e o segundo argumento é a string de busca. Se o padrão corresponder com a string, é retornado um objeto <code>match</code>, com informações sobre a correspondência, senão, é retornado <code>None</code>.</p>
            <p>Observe que <code>match</code> verifica a correspondência no início da string, e finaliza assim que o padrão foi encontrado.</p>
            <!-- 

^ início da linha
$ final da linha

'helpo world' matches pattern 'hel.o world'
'hel o world' matches pattern 'hel.o world'
'helo world' does not match pattern 'hel.o world'

'hello world' matches pattern 'hel[lp]o world'
'helpo world' matches pattern 'hel[lp]o world'
'helPo world' does not match pattern 'hel[lp]o world'

'hello world' does not match pattern 'hello [a-z] world'
'hello b world' matches pattern 'hello [a-z] world'
'hello B world' matches pattern 'hello [a-zA-Z] world'
'hello 2 world' matches pattern 'hello [a-zA-Z0-9] world'

'hello' matches pattern 'hel*o'
'heo' matches pattern 'hel*o'
'helllllo' matches pattern 'hel*o'

'A string.' matches pattern '[A-Z][a-z]* [a-z]*\.'
'No .' matches pattern '[A-Z][a-z]* [a-z]*\.'
'' matches pattern '[a-z]*.*'

'0.4' matches pattern '\d+\.\d+'
'1.002' matches pattern '\d+\.\d+'
'1.' does not match pattern '\d+\.\d+'

'1%' matches pattern '\d?\d%'
'99%' matches pattern '\d?\d%'
'999%' does not match pattern '\d?\d%'

# escapando caracteres

'0.05' matches pattern '0\.[0-9][0-9]'
'005' does not match pattern '0\.[0-9][0-9]'
'0,05' does not match pattern '0\.[0-9][0-9]'

'abccc' matches pattern 'abc{3}'
'abccc' does not match pattern '(abc){3}'
'abcabcabc' matches pattern '(abc){3}'

Combined with complex patterns, this grouping feature greatly expands our patternmatching repertoire. Here's a regular expression that matches simple English sentences:
'Eat.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
'Eat more good food.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
'A good meal.' matches pattern '[A-Z][a-z]*( [a-z]+)*\.$'
             -->
            <div id="matching-a-selection-of-characters">
                <h4>Correspondendo uma seleção de caracteres</h4>
            </div>
            <div id="escaping-characters">
                <h4>Caracteres de escape</h4>
            </div>
            <div id="matching-multiple-characters">
                <h4>Correspondendo múltiplos caracteres</h4>
            </div>
            <div id="grouping-patterns-together">
                <h4>Agrupando padrões</h4>
            </div>
        </div>
        <div id="getting-information-from-regular-expressions">
            <h3>8.2.2 Obtendo informações de expressões regulares</h3>
            <p>Falar de captura de grupos com match.groups()[0]</p>
            The groups method returns a tuple of all the groups matched inside the pattern, which you can index to access a specific value. The groups are ordered from left to right. However, bear in mind that groups can be nested, meaning you can have one or more groups inside another group. In this case, the groups are returned in the order of their leftmost brackets, so the outermost group will be returned before its inner matching groups.

            In addition to the match function, the re module provides a couple of other useful functions, search and findall. The search function finds the first instance of a matching pattern, relaxing the restriction that the pattern should start at the first letter of the string. Note that you can get a similar effect by using match and putting a ^.* character at the front of the pattern to match any characters between the start of the string and the pattern you are looking for

            The findall function behaves similarly to search, except that it finds all non-overlapping instances of the matching pattern, not just the first one. Basically, it finds the first match, then it resets the search to the end of that matching string and finds the next one.

            Instead of returning a list of match objects, as you would expect, it returns a list of matching strings, or tuples. Sometimes it's strings, sometimes it's tuples. It's not a very good API at all! As with all bad APIs, you'll have to memorize the differences and not rely on intuition. The type of the return value depends on the number of bracketed groups inside the regular expression: If there are no groups in the pattern, re.findall will return a list of strings, where each value is a complete substring from the source string that matches the pattern If there is exactly one group in the pattern, re.findall will return a list of strings where each value is the contents of that group If there are multiple groups in the pattern, re.findall will return a list of tuples where each tuple contains a value from a matching group, in order

            When you are designing function calls in your own Python libraries, try to make the function always return a consistent data structure. It is often good to design functions that can take arbitrary inputs and process them, but the return value should not switch from a single value to a list, or a list of values to a list of tuples depending on the input. Let re.findall be a lesson!

            The examples in the following interactive session will hopefully clarify the differences:
            >>> import re
            >>> re.findall('a.', 'abacadefagah')
            ['ab', 'ac', 'ad', 'ag', 'ah']
            >>> re.findall('a(.)', 'abacadefagah')
            ['b', 'c', 'd', 'g', 'h']
            >>> re.findall('(a)(.)', 'abacadefagah')
            [('a', 'b'), ('a', 'c'), ('a', 'd'), ('a', 'g'), ('a', 'h')]
            >>> re.findall('((a)(.))', 'abacadefagah')
            [('ab', 'a', 'b'), ('ac', 'a', 'c'), ('ad', 'a', 'd'), ('ag', 'a', g'), ('ah', 'a','h')]

            <div id="making-repeated-regular-expressions-efficient">
                <h4>Usando regex eficientemente</h4>
                <p>Toda vez que você chama <code>match</code>, <code>search</code>, ou <code>findall</code>, o Python "compila" o padrão de busca em uma estrutura interna para pesquisa rápida de strings, o que leva tempo. Para maior eficiência, se um padrão for reutilizado diversas vezes, é melhor realizar essa compilação apenas uma vez com o método <code>compile</code>.</p>
            </div>
            <div class="conclusao">
                <h4>Conclusão</h4>
                The key thing to understand is that regex is about knowing "what" you can do, not necessarily "how" to do it. 15 years regex experience, and I still have to look up rules in Google, and then use a regex tester. But, as long as you know what can be done, finding the how is trivial.
            </div>
        </div>
    </div>
    <div id="filesystem-paths">
        <h2>8.3 Caminhos de sistema de arquivos</h2>
    </div>
    <div id="serializing-objects">
        <h2>8.4 Serializando objetos</h2>
        <div id="customizing-pickles">
            <h3>8.4.1 Personalizando</h3>
        </div>
        <div id="serializing-web-objects">
            <h3>8.4.2 Serializando objetos web</h3>
        </div>
    </div>
    <div id="case-study">
        <h2>8.5 Estudo de caso</h2>
    </div>
    <div id="exercises">
        <h2>8.6 Exercícios</h2>
    </div>
</div>

<!-- exercício que substitui uma substring por outra em uma string, pra verificar se o aluno sabe que uma string é imutável, substituindo a variável pelo novo valor. -->
<!-- não esquecer de transformar a imagem em base64 ou svg -->
<!-- exercícios de regex
Is this string a valid URL?
What is the date and time of all warning messages in a log file?
Which users in /etc/passwd are in a given group?
What username and document were requested by the URL a visitor typed?
-->