<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {

        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ cssSelector: "code", languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padrão é 1.21, vc pode remover essa configuração se quiser deixar o padrão */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* Remove a margem interna de tags pre dentro de tabelas */
            margin: 0;
            padding: 0;
            text-align: left;
        }

        td:has(pre) {
            /* tags pre dentro de tabela são alinhadas no topo à esquerda */
            vertical-align: top;
        }

        table.align-left th,
        table.align-left td {
            /* alinha à esquerda as células da tabela */
            text-align: left;
        }

        /* inicia a lista de exercícios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* põe um numerador num item da lista de exercícios, desde que não seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* põe uma barra vertical ao lado do item da lista de exercícios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }
    </style>
</head>

<div id="6-python-data-structures">
    <h1>6 Estruturas de dados do Python</h1>
    <div id="6-1-empty-objects">
        <h2>Objetos vazios</h2>
        <p>Se toda classe herda de <code>object</code>, poderíamos instanciar um <code>object</code> diretamente. Entretanto, não podemos adicionar atributos a um objeto <code>object</code>:</p>
        <pre><code>>>> o = object()
>>> o.x = 5
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'object' object has no attribute 'x'</code></pre>
        <p>O Python desabilita propriedades arbitrárias em várias classes integradas, por padrão, para economizar memória. Também é possível desabilitar propriedades arbitrárias em nossas próprias classes usando <b>slots</b>, mas isto está além do escopo deste livro.</p>
        Mas você pode instanciar objetos de suas próprias classes e adicionar atributos posteriormente:
        <pre><code>>>> class MyObject(): pass
... 
>>> m = MyObject()
>>> m.x = "hello"
>>> m.x
'hello'</code></pre>
        <p>Entretanto, se você precisa apenas agrupar dados relacionados, pode usar classes do Python feitas para isso. Lembre-se, um objeto só faz sentido se tiver tanto dados quanto comportamentos.</p>
    </div>
    <div id="6-2-tuples-and-named-tuples">
        <h2>Tuplas e tuplas nomeadas</h2>
        <p>Tuplas nada mais são do que listas imutáveis, isto é, você não pode adicionar ou excluir objetos de uma tupla depois de instanciada. Esta propriedade garante a integridade dos dados, tornando as tuplas adequadas para representar valores que devem permanecer constantes ao longo do programa. Quando você precisa de uma coleção ordenada de elementos que não devem ser modificados, tupla é uma melhor alternativa à lista.</p>
        <p>O principal propósito de uma tupla é agregar diferentes partes de dados em um único contêiner. Por exemplo, para criar uma tupla contendo o código de uma ação, e seus preços atual, maior e menor do dia:</p>
        <pre><code>>>> stock = "FB", 177.46, 178.67, 175.79
>>> stock = ("FB", 177.46, 178.67, 175.79)</code></pre>
        <p>As duas linhas anteriores são equivalente. Ao instanciar uma tupla, os parênteses são opcionais, ao não ser que esteja dentro de outros parênteses, como um argumento de função. Por exemplo, a seguinte função recebe os dados de duas ações e retorna a ação que teve a maior subida percentual de preço:</p>
        <pre><code>def calculate_percentage_change(lowest, highest):
    if lowest > highest:
        lowest, highest = highest, lowest
    return highest / lowest - 1
 
def get_stock_with_highest_percentage_change(stock1, stock2):
    code1, _, lowest_price1, highest_price1 = stock1
    code2, _, lowest_price2, highest_price2 = stock2
 
    percentage_change1 = calculate_percentage_change(lowest_price1, highest_price1)
    percentage_change2 = calculate_percentage_change(lowest_price2, highest_price2)
 
    if percentage_change1 > percentage_change2:
        return code1, percentage_change1
    else:
        return code2, percentage_change2
 
stock = ("GOOGL", 1200.0, 1100.0, 1300.0)
 
result = get_stock_with_highest_percentage_change(("AAPL", 150.0, 140.0, 160.0), stock)
 
print(f"Stock with the highest percentage change: {result[0]}")
print(f"Average value of the share with the highest percentage change: {result[1]}")</code></pre>

        <p>Nas linhas 3, 7 e 8 fizemos <b>desempacotamento</b> (unpacking), ou <b>destruturação</b> (destructuring) da tupla, um recurso que lhe permite atribuir valores de objetos iteráveis (como tupla e lista) a múltiplas variáveis em uma única linha. Por convenção, quando destruturamos um valor que não precisamos, usamos o <code>_</code>, como nas linhas 7 e 8.</p>
        <p>Se você quiser inicializar várias variáveis em uma única linha, pode usar desempacotamento de tuplas:</p>
        <pre><code># jeito pythônico de ser
a, b, c = 10, 20, 30

# em outras linguagens vc faria algo assim:
# a=10, b=20, c=30</code></pre>
        <p>Uma tupla pode ser imutável, mas os itens dentro dela não necessariamente:</p>
        <pre><code>tuple1 = (11, [22, 33], 44, 55)
print("original:", tuple1)

tuple1[1][0] = 222 # a lista dentro da tupla pode ser modificada
print("modificada:", tuple1)</code></pre>

        <p>Você também pode ter uma tupla com um único item. Neste caso, para diferenciar de um valor isolado, deve haver uma vírgula após o item:</p>
        <pre><code>a_tuple = (42,)
not_a_tuple = (42)
a_int = 42
print(a_tuple, not_a_tuple, a_int)
print(type(a_tuple), type(not_a_tuple), type(a_int))</code></pre>
        <p>Ainda, percebemos que tuplas podem carecer de legibilidade, pois os dados dentro dela não são nomeados.</p>

        <div id="6-2-1-named-tuples">
            <h3>Tuplas nomeadas</h3>
            <p>Se não precisarmos adicionar comportamento ao objeto e soubermos antecipadamente quais atributos precisamos armazenar, podemos usar uma tupla nomeada. Tuplas nomeadas são uma ótima maneira de agrupar dados somente-leitura.</p>
            <pre><code>from collections import namedtuple

Stock = namedtuple("Stock", ("symbol", "current", "high", "low"))
stock1 = Stock("FB", 177.46, 178.67, 175.79)
print(stock1.high, stock1[3])
stock2 = Stock("AAPL", 150.0, 140.0, 160.0)
symbol, current, high, low = stock2
print(symbol, current)

stock1.low = 0 # can't set attribute
stock1.average = 176 # can't create attribute</code></pre>
            <p>O primeiro argumento de <code>namedtuple</code> é o nome da tupla nomeada, e o segundo é um iterável contendo os nomes dos atributos da tupla nomeada. O retorno é um objeto que pode ser chamado como uma classe normal para instanciar objetos.</p>
            <p>Tuplas nomeadas são como tuplas, podemos acessar seus "atributos" via índices, e não podemos modificar ou acrescentar atributos.</p>
        </div>
    </div>
    <div id="6-3-dataclasses">
        <h2>Dataclasses</h2>
        <p>Para conseguirmos modificar ou acrescentar atributos, podemos usar <code>dataclass</code>:</p>
        <pre><code>from dataclasses import make_dataclass
Stock = make_dataclass("Stock", ("symbol", "current", "high", "low"))</code></pre>
        <p>Observe a alternativa tradicional de criar uma classe, como fica mais verboso:</p>
        <pre><code>class StockRegular:
    def __init__(self, name, current, high, low):
        self.name = name
        self.current = current
        self.high = high
        self.low = low</code></pre>

        <p>Agora só usar como se fosse um objeto comum.</p>
        <pre><code>stock1 = Stock("FB", 177.46, high=178.67, low=175.79)
stock2 = Stock("FB", 177.46, high=178.67, low=175.79)

print(stock1)
print(stock1 == stock2)

stock1.current = 178.25
stock1.unexpected_attribute = "allowed"

print(stock1)
print(stock1 == stock2)</code></pre>

        <p>Outra vantagem de <code>dataclass</code> é que você ganha de brinde os métodos para converter em string e comparar objetos, diferentemente de classes tradicionais:</p>
        <pre><code>stock_regular1 = StockRegular("FB", 177.46, high=178.67, low=175.79)
stock_regular2 = StockRegular("FB", 177.46, high=178.67, low=175.79)

print(stock_regular1)
print(stock_regular1 == stock_regular2)</code></pre>
        <div id="6-3-1-dataclass-decorator">
            <h3>A decoração <code>@dataclass</code></h3>
            <p>A decoração <code>@dataclass</code> declara <code>dataclass</code>es com tipagem. Apesar da sintaxe não ser tão menos verbosa quanto classes tradicionais, <code>dataclassse</code> vem com vários recursos interessantes:</p>
            <pre><code>from dataclasses import dataclass


@dataclass(order=True)
class Movie:
    title: str
    release_year: int
    release_month: int = None
    release_day: int = None
    rating: float = None

    def better_than(self, other):
        return self.rating > other.rating


movie1 = Movie("Ocean's Eleven", 2001, 12, rating=7.7)
movie2 = Movie("Ocean's Eleven", 1960, rating=6.5)

print(movie1)
print(movie2)
print(movie1 &lt; movie2)
print(movie1.better_than(movie2))</code></pre>

            <p>Tipagem em Python <a href="https://peps.python.org/pep-0484/#non-goals">não são forçadas</a> em tempo de execução e não são necessárias para a execução correta do código. No entanto, elas podem ser usadas por ferramentas de terceiros, como verificadores de tipo (type checkers), IDEs, linters, etc., e podem ser usadas para verificação de tipo durante o desenvolvimento.</p>
            <p>É possível atribuir valores padrões aos atributos e, com o argumento <code>order=True</code>, torna-se possível realizar não apenas verificações de igualdade, mas também comparações como menor ou maior. A comparação, por padrão, é feita por atributo, seguindo a ordem em que foram declarados, até que atributos com valores distintos sejam encontrados. Você pode alterar o modo de comparação, bem como utilizar vários outros recursos oferecidos pela classe <code>dataclass</code>. Para mais informações, <a href="https://realpython.com/python-data-classes/#more-flexible-data-classes">acesse aqui</a>.</p>
        </div>
    </div>
    <div id="6-4-dictionaries">
        <h2>Dicionários</h2>
        <p>Um dicionário, em Python, é uma coleção de pares chave-valor. Dicionários em Python são implementados como tabelas hash, uma estrutura de dados altamente eficiente para buscar por itens. A sintaxe de dicionários em Python é parecida com objetos JSON:</p>
        <pre><code>stocks = {
    "AAPL": (150.0, 140.0, 160.0),
    "GOOG": (1235.20, 1242.54, 1231.06),
    "MSFT": (110.41, 110.45, 109.84),
    "FB": (177.46, 178.67, 175.79),
}</code></pre>
        <p>Um dicionário é um objeto, como qualquer outro em Python, que tem seus próprios métodos. Dentre eles se destacam:</p>
        <pre><code>>>> stocks["GOOG"]
(1235.20, 1242.54, 1231.06)
>>> stocks["RIM"]
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'RIM'
>>> print(stocks.get("RIM"))
None
>>> stocks.get("RIM", "NOT FOUND")
'NOT FOUND'
>>> stocks.setdefault("GOOG", "INVALID")
(613.3, 625.86, 610.5)
>>> stocks.setdefault("BBRY", (10.87, 10.76, 10.90))
(10.50, 10.62, 10.39)
>>> stocks["BBRY"]
(10.50, 10.62, 10.39)
>>> stocks["GOOG"] = (1245.21, 1252.64, 1245.18)
>>> stocks["GOOG"]
(1245.21, 1252.64, 1245.18)
>>> del stocks["GOOG"]
>>> stocks["GOOG"]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'GOOG'</code></pre>
        <p>A diferença entre os métodos <code>get</code> e <code>setdefault</code> é que este, além de retornar um valor padrão caso a chave não se encontre no dicionário, também adiciona no dicionário essa chave com o valor padrão.</p>
        <p>Também temos os métodos <code>keys</code>, <code>values</code> e <code>items</code>, que retornam, respectivamente, um iterador das chaves, valores e tuplas chave-valor do dicionário:</p>
        <pre><code>>>> stocks.keys()
dict_keys(['AAPL', 'GOOG', 'MSFT', 'FB'])
>>> for prices in stocks.values(): prices
... 
(150.0, 140.0, 160.0)
(1235.2, 1242.54, 1231.06)
(110.41, 110.45, 109.84)
(177.46, 178.67, 175.79)
>>> for stock, prices in stocks.items():
...     print(f"{stock} higest value is {prices[0]}")
... 
AAPL higest value is 150.0
GOOG higest value is 1235.2
MSFT higest value is 110.41
FB higest value is 177.46</code></pre>
        <p>Observe que ao iterar pelas tuplas, podemos desempacotar a chave e o valor em variáveis.</p>
        <p>Embora o comum seja usar strings como chaves, podemos usar qualquer objeto "hasheável":</p>
        <pre><code>random_keys = {}
random_keys["astring"] = "somestring"
random_keys[5] = "aninteger"
random_keys[25.2] = "floats work too"
random_keys[("abc", 123)] = "so do tuples"

class AnObject:
    def __init__(self, avalue):
        self.avalue = avalue

my_object = AnObject(14)
random_keys[my_object] = "We can even store objects"
my_object.avalue = 12

try:
    random_keys[[1, 2, 3]] = "we can't store lists though"
except:
    print("unable to store list\n")

for key, value in random_keys.items():
    print(f"{key} has value {value}")</code></pre>

        <p>Geralmente objetos mutáveis, como listas e dicionários, não são hasheáveis, portanto, não podem ser usados como chaves de dicionários. O valor <b>hash</b> de um objeto é como se fosse sua "impressão digital": permanece a mesma enquanto o objeto existir. Por padrão, o hash de objetos de classes personalizadas é um número equivalente ao seu endereço de memória, que é inclusive usado ao imprimir ou comparar o objeto quando não se sobrescrevem os métodos <code>__str__</code> e <code>__eq__</code>. Você também pode sobrescrever o método <code>__hash__</code>, caso queira calcular e retornar um hash baseado nos valores dos atributos do objeto.</p>
        <p>Tecnicamente, a maioria dos objetos em Python é implementada utilizando dicionários nos bastidores. A maioria dos objetos possui o atributo mágico <code>obj.__dict__</code>. Quando você acessa um atributo em um objeto usando <code>obj.nome_do_atributo</code>, essencialmente isso é traduzido para <code>obj['nome_do_atributo']</code> nos bastidores.</p>

        <div id="6-4-1-dictionary-use-cases">
            <h3>Casos de uso de dicionários</h3>
            <p>Um dicionário poderia ser usado para armazenar informações específicas de um tipo de dados, como uma ação da bolsa...</p>
            <pre><code>aapl = {"code": "AAPL", "current": 150.0, "low": 140.0, "high": 160.0}</code></pre>
            <p>... ou até mesmo para armazenar informações de vários dados de um tipo:</p>
            <pre><code>stocks = {
    "AAPL": aapl,
    "GOOG": {"current": 1235.2, "low": 1242.54, "high": 1231.06},
    "MSFT": {"current": 110.41, "low": 110.45, "high": 109.84}
}</code></pre>

            <p>Quando usar dicionários, dataclasses ou tuplas?</p>
            <p>Quando sabemos exatamente quais atributos um dado deve armazenar, especialmente se quisermos manter uma certa documentação, podemos usar dataclasses.</p>
            <p>Na verdade, como dataclasses veio depois de tuplas nomeadas, a tendência é que passem a ser mais utilizadas. Mas para casos em que queiramos usar desempacotamento ou iteração, podemos escolher tuplas nomeadas.</p>
            <p>Dicionários podem ser mais interessantes quando não sabemos de antemão quais os atributos de um dado, ou se nem todos os dados terão os mesmos atributos, e também quando precisamos fazer consultas rápidas de dados pelas chaves.</p>
        </div>
        <div id="6-4-2-using-defaultdict">
            <h3>Usando <code>defaultdict</code></h3>
            <p>Um caso de uso típico para dicionários é o problema de contar o número de ocorrências de cada elemento de uma sequência:</p>
            <pre><code>def letter_frequency(sentence):
    frequencies = {}
    for letter in sentence:
        frequency = frequencies.setdefault(letter, 0)
        frequencies[letter] = frequency + 1
    return frequencies</code></pre>
            <p>Para garantir que não vamos tentar modificar o valor de uma chave que não existe, usamos o método <code>setdefault</code> para cada chave. Podemos definir um valor padrão para todas as chaves de uma vez com <code>defaultdict</code>:</p>
            <pre><code>from collections import defaultdict
def letter_frequency(sentence):
    frequencies = defaultdict(int)
    for letter in sentence:
        frequencies[letter] += 1
    return frequencies</code></pre>
            <p>O construtor da classe <code>defaultdict</code> aceita uma função como argumento, que é chamada sempre que se tenta acessar ou modificar uma chave que não existe. No caso, a função <code>int</code> quando chamada sem argumentos, retorna o valor zero.</p>
            <p id="defaultdict-custom-function">Considere o seguinte problema: Queremos implementar um dicionário de definição de palavras, mas também queremos saber em que ordem cada palavra foi adicionada. Uma possível solução:</p>
            <pre><code>from collections import defaultdict

num_items = 0

def tuple_counter():
    global num_items
    num_items += 1
    return [num_items, ""]

d = defaultdict(tuple_counter)

d["pindaíba"][1] = "falta de dinheiro"
d["gororoba"][1] = "comida duvidosa"
d["bugiganga"][1] = "quinquilharia"
d["bizu"][1] = "ideia"

print(f'gororoba significa {d["gororoba"][1]}, e foi a {d["gororoba"][0]}ª palavra a ser adicionada neste dicionário.')</code></pre>
            <p>Esse exemplo, meramente para demonstrar uma função própria passada como argumento a <code>defaultdict</code>, possui algumas limitações. Por exemplo, se quiséssemos ter mais de um dicionário, precisaríamos de uma variável global para cada um. Além de que a interface com o programador não é tão amigável. Nos exercícios proporemos uma melhora neste código.</p>
            <div id="6-4-2-1-counter">
                <h4>Contador</h4>
                <p>O problema de contar o número de ocorrências é tão comum que a galera do Python criou uma classe especificamente para isso:</p>
                <pre><code>from collections import Counter
def letter_frequency(sentence):
    return Counter(sentence)</code></pre>
                <p>O objeto da classe <code>Counter</code> é basicamente um dicionário em que as chaves são cada um dos elementos de <code>sentence</code> e os valores são suas respectivas quantidades. Esse objeto também possui o método <code>most_common</code>, que pode receber um inteiro <code>x</code> e retorna uma lista ordenada com as <code>x</code> chaves e respectivos valores que mais ocorreram:</p>
                <pre><code>from collections import Counter

responses = [
    "vanilla",
    "chocolate",
    "vanilla",
    "vanilla",
    "caramel",
    "chocolate",
    "strawberry",
    "vanilla",
]

print("The children voted for", Counter(responses).most_common(1)[0][0], "ice cream")</code></pre>
                <p><code>Counter(responses)</code> retorna um objeto contador. O método <code>most_common</code> sempre retorna uma lista, mesmo que esta possua apenas um item. Portanto, <code>most_common(1)</code> retorna uma lista com um único item, o que mais ocorreu, e o primeiro índice <code>[0]</code> acessa esse item. O segundo índice <code>[0]</code> acessa o nome do item, já que se o segundo índice fosse <code>[1]</code>, estaria acessando a quantidade de ocorrências daquele item. Veja um exemplo equivalente destrinchado do <code>print</code> anterior:</p>
                <pre><code>result = Counter(responses)
most_voted = result.most_common(2)
first_most_voted = most_voted[0]
second_most_voted = most_voted[1]
# third = most_voted[2] # error, only checked the top 2 most voted!
first_name = first_most_voted[0]
first_votes_count = first_most_voted[1]
print("The children voted for", first_name, "ice cream, with", first_votes_count, "votes.")</code></pre>
            </div>
        </div>
        <div id="6-4-1-exercises">
            <h3>Exercícios</h3>
            <ol class="excs">
                <li>
                    <b>API de Preços de Ações</b>
                    <p>Crie uma API que mantém uma lista dos preços de fechamento de várias ações ao longo dos dias. Utilize dicionários, em que as chaves representam o código da ação e os valores são listas de tuplas contendo a data e o preço de fechamento. Implemente os seguintes métodos:</p>
                    <ul>
                        <li><code>add(code, date, closing_price)</code>: adiciona informações de preço de fechamento para uma ação específica em uma determinada data. Certifique-se de lidar com casos em que a ação ainda não possui uma entrada no dicionário, usando <code>defaultdict</code>.</li>
                        <li><code>get_prices(code)</code>: Retorna a lista de tuplas contendo a data e o preço de fechamento para uma ação específica.</li>
                        <li><code>get_all_stocks()</code>: Retorna uma lista com todos os códigos de ações presentes no dicionário.</li>
                        <li><code>average_price(code)</code>: Retorna a média dos preços de fechamento de uma ação específica.</li>
                        <li><code>recent_prices(code, date)</code>: Retorna uma lista com os preços de fechamento de uma ação específica a partir da data <code>date</code>.</li>
                    </ul>
                </li>
                <li>
                    <b>Dicionário de definição de palavras</b>
                    <p>Melhore a solução proposta para o problema do dicionário de palavras <a href="#defaultdict-custom-function">definido anteriormente</a>. Crie uma API com os seguintes métodos:</p>
                    <ul>
                        <li><code>set(word, definition)</code>: Adiciona ou modifica a definição de uma palavra.</li>
                        <li><code>get(word)</code>: Retorna a definição de uma palavra. Se a palavra não existir no dicionário, retorna uma mensagem indicando que a palavra não foi encontrada.</li>
                        <li><code>get_word_order(word)</code>: Retorna a ordem em que uma palavra foi adicionada/modificada no dicionário. A ordem deve ser um número inteiro representando a posição da palavra na sequência de adições/modificações.</li>
                        <li><code>get_all_words()</code>: Retorna uma lista com todas as palavras presentes no dicionário, na ordem em que foram adicionadas/modificadas.</li>
                    </ul>
                </li>
                <li>
                    <b>Sistema de eleições</b>
                    <p>Crie um programa para gerenciar uma eleição. Primeiramente, será necessário cadastrar os candidatos e associá-los às suas respectivas chapas. Em seguida, o programa deverá ler a lista de votos, onde cada voto é representado pelo número da chapa do candidato votado.</p>
                    <p>Primeiramente o programa lê a quantidade de candidatos, seguida pelo número da chapa e o nome (única palavra, sem espaços) de cada candidato. Depois o programa lê a quantidade de votos, seguida pelos números das chapas votadas. Caso haja algum número sem chapa cadastrada, considerar como voto nulo. Por fim, o programa deve exibir os dois candidatos mais votados, e a mensagem "SEM SEGUNDO TURNO" ou "COM SEGUNDO TURNO", caso o primeiro candidato tenha conseguido mais de 50% dos votos ou não. Caso haja empate, o critério de desempate é a ordem alfabética. A entrada e saída de dados deve obedecer ao seguinte padrão de exemplo:</p>
                    <table class="custom">
                        <thead>
                            <tr>
                                <th>Entrada</th>
                                <th>Saída</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <pre>3
14
Fulano
42
Beltrano
20
Sicrano
5
20
14
0
42
20</pre>
                                </td>
                                <td>
                                    <pre>Sicrano
Beltrano
COM SEGUNDO TURNO</pre>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </li>
                <!-- Faltou um exercício que seja interessante usar a classe counter... -->
            </ol>
        </div>
    </div>
    <div id="6-5-lists">
        <h2>Listas</h2>
        <p>Listas são classes de objetos em Python que suportam sintaxes personalizadas que encapsulam seu uso, sem a necessidade de chamar métodos explicitamentes, como a capacidade de instanciar objetos sem explicitamente chamar construtores, ou realizar muitas outras operações como <i>list comprehension</i> ou <i>slice notation</i>.</p>
        <p>Listas geralmente são usadas para armazenar vários objetos do mesmo tipo; listas de strings, listas de números, ou listas de objetos próprios.</p>
        <p>Apesar de possível, evite armazenar elementos de tipos diferentes em uma mesma lista. Por exemplo, para armazenar pares de letra/ocorrências, poderíamos ter <code>['a', 1, 'b', 3]</code>, que significa que a letra 'a' ocorreu 1 vez e a letra 'b' ocorreu 3 vezes. Mas pensa na hora de iterar por essa lista como seria mais complicado. Uma solução melhor, mas não necessariamente a melhor de todas, seria <code>[('a',1), ('b',3)]</code>.</p>
        <p>Dentre os métodos mais utilizados de listas, se encontram:</p>
        <ul>
            <li><code>append(element)</code>: Adiciona <code>element</code> no final da lista.</li>
            <li><code>insert(i, element)</code>: Adiciona <code>element</code> numa posição específica da lista.</li>
            <li><code>count(element)</code>: Conta quantas vezes <code>element</code> aparece na lista.</li>
            <li><code>index(element)</code>: Retorna o índice onde <code>element</code> se encontra na lista, ou levanta uma exceção caso não se encontre na lista.</li>
            <li><code>find(element)</code>: Que nem <code>index(element)</code>, mas retorna -1 em vez de levantar exceção.</li>
            <li><code>reverse()</code>: Inverte a lista <i>in-loco</i> (a modifica). Para retornar um iterador que percorre uma lista <code>l</code> de trás para frente, use a função <code>reversed(l)</code>.</li>
            <li><code>sort()</code>: Ordena a lista <i>in-loco</i> (a modifica). Para retornar uma cópia ordenada da lista <code>l</code>, use a função <code>sorted(l)</code>.</li>
        </ul>
        <div id="6-5-1-sorting-lists">
            <h3>Ordenando listas</h3>
            <p>O método <code>sort</code> chama o método mágico <code>__lt__</code> (abreviação de “menor que”) para comparar os elementos da lista. A maioria das classes padrão do Python já vêm com <code>__lt__</code> implementado. Se tentar ordenar objetos que não possuam <code>__lt__</code>, uma exceção é levantada.</p>
            <pre><code>class WeirdSortee:
    def __init__(self, string, number):
        self.string = string
        self.number = number

    def __lt__(self, other):
        return self.number < other.number

    def __repr__(self):
        return f"{self.string}:{self.number}"</code></pre>

            <p>O método mágico <code>__lt__</code> deve retornar <code>True</code> caso <code>self</code> seja menor que <code>other</code>, ou <code>False</code> caso contrário. Esse método é chamado automaticamente pelo método <code>sort</code>. Já o método mágico <code>__repr__</code> deve retornar uma representação em string do objeto, e é chamado automaticamente pela função <code>print</code>. Veja uma ilustração de uso dessa classe:</p>
            <pre><code>>>> a = WeirdSortee("a", 4)
>>> b = WeirdSortee("B", 3)
>>> c = WeirdSortee("c", 2)
>>> d = WeirdSortee("d", 1)
>>> l = [a, b, c, d]
>>> print(l)
[a:4, b:3, c:2, d:1]
>>> l.sort()
>>> print(l)
[d:1, c:2, b:3, a:4]</code></pre>

            <p>E se quisermos ordenar nossa lista de objetos de um modo diferente ao definido pelo <code>__lt__</code>? Também podemos passar uma função como argumento ao parâmetro <code>key</code> do método <code>sort</code>, que deve retornar o valor a ser comparado de cada objeto da lista. Seguindo a ilustração anterior, agora ordenando por outro atributo:</p>
            <pre><code>>>> a = WeirdSortee("a", 4)
>>> b = WeirdSortee("B", 3)
>>> c = WeirdSortee("c", 2)
>>> d = WeirdSortee("d", 1)
>>> l = [a, b, c, d]
>>> print(l)
[a:4, B:3, c:2, d:1]
>>> l.sort()
>>> print(l)
[d:1, c:2, B:3, a:4]
>>>
>>> def custom_order(obj):
...     return obj.string.lower()
...
>>> l.sort(key=custom_order)
>>>
>>> print(l)
[a:4, B:3, c:2, d:1]</code></pre>
            <p>Observe que a função <code>custom_order</code> retorna o valor em minúsculo do atributo <code>string</code>, para normalizar a ordenação de letras maiúsculas e minúsculas, senão, as letras maiúsculas são ordenadas à frente das letras minúsculas.</p>

            <p>Podemos usar muitas das funções integradas do Python para personalizar a ordenação de objetos:</p>
            <pre><code>>>> l = ["hello", "HELP", "Helo"]
>>> l
['hello', 'HELP', 'Helo']
>>> l.sort()
>>> l
['HELP', 'Helo', 'hello']
>>> l.sort(key=str.lower)
>>> l
['hello', 'Helo', 'HELP']</code></pre>
            <p>A função <code>lower</code> da classe <code>str</code> retorna a versão minúscula da string passada como argumento.</p>

            <p>Por padrão, tuplas são ordenadas pelo valor de seus primeiros itens, mas podemos modificar esse comportamento através da função incorporada <code>operator.itemgetter</code>:</p>
            <pre><code>>>> from operator import itemgetter
>>> 
>>> l = [('n', 6), ('o', 5), ('h', 4), ('t', 3), ('y', 2), ('p', 1)]
>>> l
[('n', 6), ('o', 5), ('h', 4), ('t', 3), ('y', 2), ('p', 1)]
>>>
>>> l.sort()
>>> l
[('h', 4), ('n', 6), ('o', 5), ('p', 1), ('t', 3), ('y', 2)]
>>>
>>> l.sort(key=itemgetter(1))
>>> l
[('p', 1), ('y', 2), ('t', 3), ('h', 4), ('o', 5), ('n', 6)]</code></pre>
            <p>A função <code>operator.itemgetter(i)</code> retorna uma função que retorna o i-ésimo elemento de um objeto iterável, como uma tupla, lista ou dicionário. Similarmente, para retornar um atributo específico de um objeto, você pode usar a função <code>operator.attrgetter</code>. Mais detalhes na <a href="https://docs.python.org/3/library/operator.html#operator.attrgetter">documentação oficial</a>.</p>
        </div>
    </div>
    <div id="6-6-sets">
        <h2>Conjuntos</h2>
        <p>A classe de objetos <code>set</code> lembra conjuntos da matemática, e é usada para armazenar elementos únicos (sem duplicatas). Similarmente aos dicionários, conjuntos em python usam tabela hash como estrutura de dados subjacente, que não mantém uma ordenação dos elementos, mas consegue buscar rapidamente por eles dentro do conjunto.</p>
        <p>Como exemplo de uso, suponha que você tenha uma coleção de músicas, de vários artistas, e quer uma lista com todos os artistas. Como um artista pode ter várias músicas, você precisa de um meio de filtrar o resultado, para ele não aparecer várias vezes.</p>
        <pre><code>song_library = [
("Phantom Of The Opera", "Sarah Brightman"),
("Knocking On Heaven's Door", "Guns N' Roses"),
("Captain Nemo", "Sarah Brightman"),
("Patterns In The Ivy", "Opeth"),
("November Rain", "Guns N' Roses"),
("Beautiful", "Sarah Brightman"),
("Mal's Song", "Vixy and Tony"),
]

artists = set()
for song, artist in song_library:
    artists.add(artist)

print(artists)

if "Opeth" in artists:
    print("Opeth in artists")

for artist in artists:
    print(artist, "plays good music")</code></pre>
        <p>Observe que os elementos não são impressos na ordem em que foram colocados. Você pode usar o operador <code>in</code> para consultar e percorrer elementos do conjunto. Mas não pode usar índices para acessar elementos específicos. E para ordená-los, precisa converter para uma lista antes.</p>
        <p>Diferentemente de listas, dicionários e tuplas, que possuem sintaxes específicas para inicializar seus objetos vazios, com conjuntos, você precisa chamar explicitamente o construtor. Mas para inicializar um conjuto com elementos iniciais, a sintaxe fica parecida com dicionários, exceto que não vai o dois-pontos. Você também pode passar qualquer objeto iterável como argumento no construtor de conjuntos:</p>
        <pre><code>>>> x = {'foo', 'bar', 'baz', 'foo', 'qux'}
>>> x
{'qux', 'foo', 'bar', 'baz'}
>>> x = set(['foo', 'bar', 'baz', 'foo', 'qux'])
>>> x
{'qux', 'foo', 'bar', 'baz'}
>>> x = set(('foo', 'bar', 'baz', 'foo', 'qux'))
>>> x
{'qux', 'foo', 'bar', 'baz'}
>>> x = set('quux')
>>> x
{'x', 'u', 'q'}</code></pre>
        <p>Como conjuntos da matemática, <code>set</code>s suportam operaçoes de união, intersecção e diferença simétrica, dentre outros.</p>
        <pre><code>my_collection = {
"Sarah Brightman",
"Guns N' Roses",
"Opeth",
"Vixy and Tony",
}

your_collection = {"Nickelback", "Guns N' Roses", "Savage Garden"}

print("All:", my_collection.union(your_collection))
print("Both:", your_collection.intersection(my_collection))
print("Either but not both:", my_collection.symmetric_difference(your_collection))</code></pre>
        <p><code>set</code>s também suportam operações de conjuntos contém, contido e diferença:</p>
        <pre><code>mine = {"Sarah Brightman", "Guns N' Roses", "Opeth", "Vixy and Tony"}

yours = {"Guns N' Roses", "Opeth"}

print("first_artists is to bands:")
print("issuperset:", mine.issuperset(yours))
print("issubset:", mine.issubset(yours))
print("difference:", mine.difference(yours))

print("*" * 20)

print("bands is to first_artists:")
print("issuperset:", yours.issuperset(mine))
print("issubset:", yours.issubset(mine))
print("difference:", yours.difference(mine))</code></pre>

        <p>Os métodos <code>union</code>, <code>intersection</code> e <code>difference</code> aceitam múltiplos argumentos.</p>
        
        <p>Como os métodos sugerem, <code>set</code>s são bons para situações em que você tem que comparar dados de fontes diferentes. Por exemplo, combiná-los, determinar quais se sobrepõem ou não (elementos contidos em ambos os conjuntos), ou remover duplicatas. Tudo isso garantindo um ótimo desempenho que não seria possível usando listas. Por exemplo, apesar do operador <code>in</code> estar disponíel tanto para conjuntos quanto para listas, ele é muito mais eficiente em conjuntos do que em listas: Em listas, é necessário percorrer a lista até encontrar pelo objeto procurado, se houver; Em conjuntos, não importa o tamanho deles, devido à tabela hash, a busca demora um fator constante de tempo.</p>

        <div id="6-6-1-exercises">
            <h3>Exercícios</h3>
            <ol class="excs">
                <li class="no-mark">Para os seguintes exercícios, escolher estruturas de dados que melhor atendam ao critério de desempenho.</li>
                <li>Ler uma sequência de números, que se encerra com um número repetido. Escrever os números ordenadamente.</li>
                <li>Ler um número $n$, seguido por uma sequência de $n$ números. Escrever os números, sem duplicatas, ordenadamente.</li>
                <li>Ler duas frases, uma em cada linha. Escrever em uma linha as palavras da primeira frase que não ocorrem na segunda frase. Escrever em outra linha as palavras da primeira frase que oorrem na segunda frase.</li>
                <li>Ler dois arquivos de texto diferentes. Escrever as palavras presentes em ambos os arquivos, sem duplicatas.</li>
                <li>Ler dois arquivos de texto diferentes. Escrever as palavras presentes em pelo menos um dos arquivos, sem duplicatas.</li>
                <li>Um pangrama é uma frase em que são usadas todas as letras do alfabeto de determinada língua. Exemplo de pangrama em inglês: The quick brown fox jumps over the lazy dog. Exemplo de pangrama em português, desconsiderando as letras de origem saxônica: Blitz prende ex-vesgo com cheque fajuto.
                    <p>Ler um número $n$, seguido por $n$ frases, uma em cada linha. Para cada frase, escrever "S" ou "N" caso seja pangrama inglês ou não (desconsidera acentos).</p>
                </li>
                <li>Um heterograma é uma palavra ou frase em que nenhuma letra do alfabeto ocorre mais de uma vez.
                    <p>Ler um número $n$, seguido por $n$ frases, uma em cada linha. Para cada frase, escrever "S" ou "N" caso seja heterograma ou não.</p>
                </li>
                <li>Um anagrama é uma palavra ou frase formada reorganizando as letras de outra palavra ou frase, usando todas as letras originais exatamente uma vez. Em outras palavras, as palavras ou frases são anagramas se tiverem as mesmas letras, mas em ordens diferentes. Exemplos de anagramas: "amor" e "roma"; "listen" e "silent"; "ator" e "rota".
                    <p>Ler um número $n$ seguido por $n$ pares de palavras, e, para cada par, escrever "S" ou "N" caso sejam anagramas ou não.</p>
                </li>
                <li><b>Lista proibida</b>. Ler um número $n$, seguido por $n$ palavras "proibidas". Depois, ler um número $m$, seguido por $m$ frases, uma em cada linha. Para cada frase, escrever "PERMITIDO" ou "CENSURADO" caso haja palavras proibidas ou não. </li>
                <li><b>Lista permitida</b>. Ler um número $n$, seguido por $n$ palavras "permitidas". Depois, ler um número $m$, seguido por $m$ frases, uma em cada linha. Para cada frase, escrever "PERMITIDO" ou "CENSURADO" caso contenha apenas palavras permitidas ou não.</li>
            </ol>
        </div>
    </div>
</div>
<!-- exercício: Como os métodos sugerem, <code>set</code>s são bons para situações em que você tem que comparar dados de fontes diferentes. Por exemplo, combiná-los, determinar quais se sobrepõem ou não (elementos contidos em ambos os conjuntos), ou remover duplicatas -->
<!-- we have data incoming that may contain duplicates of data that has already been processed, we can use
sets to compare the two and process only the new data. -->
<!-- exercício que verifica se uma frase contém todas as vogais, independentemente de maiúsculo ou minúsculo -->
<!-- aqui tem bastante exercícios interessantes de sets: https://www.geeksforgeeks.org/python-set-exercise/ -->
<!-- Another way to create the same list is pairs = [(v, k) for (k, v) in d.items()]. -->