<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {

        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <!-- https://github.com/arronhunt/highlightjs-copy -->
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padrão é 1.21, vc pode remover essa configuração se quiser deixar o padrão */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* tags pre dentro de tabelas são alinhadas à esquerda, sem margem interna */
            margin: 0;
            text-align: left;
        }

        td:has(pre) {
            /* tags pre dentro de tabela são alinhadas no topo */
            vertical-align: top;
        }

        code:not(pre code) {
            /* tags code não filhas de pre */
            color: darkred;
            background-color: #f3f3f3;
        }

        table.align-left th,
        table.align-left td {
            /* alinha à esquerda as células da tabela */
            text-align: left !important;
        }

        .bordered-line td {
            /* tags tr com borda em todas as suas células */
            border: 1px solid black;
        }

        /* inicia a lista de exercícios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* põe um numerador num item da lista de exercícios, desde que não seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* põe uma barra vertical ao lado do item da lista de exercícios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }

        .info {
            /* balão de informação */
            border-left: 6px solid blue;
            padding-left: 1%;
        }
    </style>
</head>

<div id="7-python-object-oriented-shortcuts">
    <h1>7 Atalhos orientados a objetos de Python</h1>
    <div id="7-1-python-built-in-functions">
        <h2>Funções incorporadas do Python</h2>
        <p>Muitas dessas funções empregam duck typing: esperam receber objetos com determinados atributos, mas não forçam os objetos a serem de determinada classe.</p>
        <div id="7-1-1-the-len-function">
            <h3>A função <code>len</code></h3>
            <p>Muitos objetos são contáveis, como strings, dicionários ou listas. Internamente, eles implementam o método <code>__len__</code>, que é invocado implicitamente ao passá-los como argumento à função <code>len</code>. Portanto, para saber a quantidade de caracteres numa string, por exemplo, podemos fazer:</p>
            <pre><code>>>> string = 'eu tenho 22 caracteres' 
>>> string.__len__() # orientado a objetos
22
>>> len(string) # implicitamente orientado a objetos
22</code></pre>
            <p>Embora em muitas linguagem o habitual seja invocar um método do tipo <code>__len__</code> do objeto, no Python, a convenção é invocar a função <code>len</code>.</p>
        </div>
        <div id="7-1-2-reversed">
            <h3>A função <code>reversed</code></h3>
            <p>A função <code>reversed</code> retorna uma cópia invertida de um objeto. Internamente, ela invoca o método <code>__reversed__</code> do objeto. Se esse método não existir, a função invoca os métodos <code>__len__</code> e <code>__getitem__</code> do objeto para conseguir percorrer seus valores de trás para frente. Lembre-se, você pode implementar os métodos mágicos para definir o funcionamento das funções incorporadas do Python. Qual a saída do seguinte código:</p>
            <pre><code>normal_list = [1, 2, 3, 4, 5]

class CustomSequence:
    def __len__(self):
        return 5
    def __getitem__(self, index):
        return f"x{index}"

class FunkyBackwards:
    def __reversed__(self):
        return "BACKWARDS!"

for seq in normal_list, CustomSequence(), FunkyBackwards():
    print(f"\n{seq.__class__.__name__}: ", end="")
    for item in reversed(seq):
        print(item, end=", ")</code></pre>
        </div>
        <div id="7-1-3-enumerate">
            <h3>A função <code>enumerate</code></h3>
            <p>A função <code>enumerate</code> retorna uma sequência de tuplas compostas pelo índice e valor de cada item de um objeto iterável. É útil quando queremos modificar uma lista enquanto a percorremos.</p>
            <pre><code>names = ["ana", "beatriz", "carla", "daiana"]

for name in names:
    name = name.upper()

print(names)

for i in range(len(names)):
    names[i] = names[i].upper()

print(names)

for i, v in enumerate(names):
    names[i] = v.lower()

print(names)</code></pre>
        </div>
        <div id="other-built-in-functions">
            <h3>Outras funções incorporadas</h3>
            <p>Lembre-se, você pode acessar a documentação do Python sem a Internet através do modo interativo, e com o comando <code>help</code>. Por exemplo, para ver informações sobre as funções incorporadas, execute <code>help(__builtins__)</code>. Para saber sobre uma função específica, como a <code>enumerate</code>, execute <code>help(enumerate)</code>. Dentre outras funções, podemos citar:</p>
            <ul>
                <li><code>abs(x)</code>: Retorna o valor absoluto de um número.</li>
                <li><code>all(iterable)</code>: Retorne True se todos os elementos de iterable forem verdadeiros (ou se o iterável estiver vazio).</li>
                <li><code>any(iterable)</code>: Retorne True se algum elemento de iterable for verdadeiro. Se iterable estiver vazio, retorne False.</li>
                <li><code>bin(x)</code>: Converte um número inteiro em uma string binária prefixada com “0b”.</li>
                <li><code>chr(i)</code>: Retorna o caractere que representa o código Unicode i. Por exemplo, chr(97) retorna a string 'a', enquanto chr(8364) retorna a string '€'. Este é o inverso de ord.</li>
                <li><code>delattr(object, name)</code>: Exclui o atributo name de object. Por exemplo, delattr(x, 'foobar') é equivalente a del x.foobar.</li>
                <li><code>dir(object)</code>: Sem argumentos, retorna a lista de nomes no escopo local atual. Com um argumento, tenta retornar uma lista de atributos válidos para esse objeto.</li>
                <li><code>exec(str)</code>: Analisa e executa o código de str. CUIDADO COM ATAQUE DE INJEÇÃO DE CÓDIGO!</li>
                <li><code>getattr(object, name)</code>: Retorna o valor do atributo name de object.</li>
                <li><code>hasattr(object, name)</code>: Retorna True se object possui o atributo name.</li>
                <li><code>hex(x)</code>: Converte um número inteiro em uma string hexadecimal minúscula prefixada com “0x”.</li>
                <li><code>isinstance(object, classinfo)</code>: Retorna True se object for uma instância de classinfo ou de uma subclasse (direta, indireta ou virtual) dele.</li>
                <li><code>max(iterable, *, key=None)</code>: Retorna o maior item de um iterável ou o maior de dois ou mais argumentos.</li>
                <li><code>min(iterable, *, key=None)</code>: Retorna o menor item de um iterável ou o menor de dois ou mais argumentos.</li>
                <li><code>ord(c)</code>: Retorna o código Unicode que o caractere c representa. É o inverso de chr.</li>
                <li><code>round(number, ndigits=None)</code>: Retorna o número arredondado com ndigits casas decimais. Se ndigits for omitido, retorna o número inteiro mais próximo.</li>
                <li><code>setattr(object, name, value)</code>: Atribui value ao atributo name de object.</li>
                <li><code>sum(iterable, /, start=0)</code>: Soma o start e os itens de iterable da esquerda para a direita e retorna o total.</li>
                <li><code>zip(*iterables, strict=False)</code>: Itera sobre vários iteráveis em paralelo, produzindo tuplas com um item de cada um. Se strict for True, levanta exceção caso os iteráveis sejam de tamanhos diferentes. Por exemplo:
                    <pre><code>>>> for item in zip([1, 2, 3], ["sugar", "spice", "everything nice"]):
...     print(item, end=" ")
...
(1, 'sugar') (2, 'spice') (3, 'everything nice')
>>> for item in zip(range(3), ["fee", "fi", "fo", "fum"]):
...     print(item, end=" ")
... 
(0, 'fee') (1, 'fi') (2, 'fo')
>>> for item in zip(range(3), ["fee", "fi", "fo", "fum"], True):
...     print(item, end=" ")
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'bool' object is not iterable</code></pre>
                </li>







            </ul>
        </div>
        <div id="7-1-4-file-i-o">
            <h3>Leitura e escrita de arquivos</h3>
            <p>A função incorporada <code>open</code> retorna um objeto que representa um arquivo. Por padrão, o arquivo é aberto no modo somente-leitura. Para abri-lo no modo escrita, devemos estipular no argumento:</p>
            <pre><code>contents = "Some file contents"
file = open("filename", "w")
file.write(contents)
file.close()</code></pre>
            <p>Se o arquivo estiver numa codificação específica diferente do padrão do sistema operacional, devemos passá-la como argumento: <code>open('file.txt', encoding='latin-1')</code>.</p>
            <p>O argumento <code>'w'</code> trunca o arquivo inteiro. Para adicionar ao final do arquivo em vez de truncá-lo, passe o argumento <code>'a'</code>, de “anexar”. Para criar um arquivo, passe o argumento <code>'x'</code>, que levanta uma exceção caso o arquivo já exista. Para abrir um arquivo binário e ler ou escrever bytes diretamente, poderíamos passar o argumento <code>'rb'</code> ou <code>'wb'</code>. Esses modos de abertura de arquivo não são específicos do Python, são um padrão estabelecido para comunicação entre o sistema operacionais e as várias linguagems de programação existentes. As possíveis combinações de <a href="https://stackoverflow.com/a/67558256/4072641">modo de abertura</a> são:</p>
            <table class="custom">
                <thead>
                    <tr>
                        <th></th>
                        <th>r</th>
                        <th>r+</th>
                        <th>x</th>
                        <th>x+</th>
                        <th>w</th>
                        <th>w+</th>
                        <th>a</th>
                        <th>a+</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><a href="https://docs.python.org/3/library/io.html#io.IOBase.readable" rel="noreferrer">readable</a></td>
                        <td>√</td>
                        <td>√</td>
                        <td></td>
                        <td>√</td>
                        <td></td>
                        <td>√</td>
                        <td></td>
                        <td>√</td>
                    </tr>
                    <tr>
                        <td><a href="https://docs.python.org/3/library/io.html#io.IOBase.writable" rel="noreferrer">writeable</a></td>
                        <td></td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>default position: start</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td>√</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>default position: end</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>√</td>
                        <td>√</td>
                    </tr>
                    <tr>
                        <td><a href="https://docs.python.org/3/library/exceptions.html#FileNotFoundError" rel="noreferrer">must exist</a></td>
                        <td>√</td>
                        <td>√</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><a href="https://docs.python.org/3/library/exceptions.html#FileExistsError" rel="noreferrer">mustn't exist</a></td>
                        <td></td>
                        <td></td>
                        <td>√</td>
                        <td>√</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>truncate (clear file) on load</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>√</td>
                        <td>√</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Always write to EOF</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>√</td>
                        <td>√</td>
                    </tr>
                </tbody>
            </table>

            <h4>Lendo</h4>
            <p>Podemos invocar os seguintes métodos no modo leitura:</p>
            <ul>
                <li><code>read(size=-1, /)</code>: Lê e retorna no máximo size caracteres como uma única string. Se size for negativo ou não especificado, lê até EOF. Cuidado ao usar esse método para arquivos grandes, pois o computador pode travar ou a memória pode transbordar.</li>
                <li><code>readline(size=-1, /)</code>: Lê até nova linha ou EOF e retorne uma única string. Se size for especificado, no máximo size caracteres serão lidos.</li>
                <li><code>readlines(hint=-1, /)</code>: Lê e retorna uma lista de linhas do arquivo. hint pode ser especificada para controlar o número de linhas lidas: nenhuma outra linha será lida se o tamanho total (em bytes/caracteres) de todas as linhas até o momento exceder hint. Assim como em <code>read</code>, pode ser perigoso invocar esse método para arquivos grandes.</li>
            </ul>
            <p>Esses métodos também funcionam para leitura de arquivos binários, apesar de que invocar um <code>readline</code> pode não fazer muito sentido.</p>
            <p>Observe que é possível iterar em objetos de arquivos usando <code>for line in file: ...</code> sem invocar <code>file.readlines()</code>.</p>

            <h4>Escrevendo</h4>
            <p>Para escrever, temos os métodos:</p>
            <ul>
                <li><code>write(s, /)</code>: Escreve s no arquivo e retorna o número de caracteres escritos.</li>
                <li><code>writelines(lines, /)</code>: Escreve uma lista de linhas no arquivo. Os separadores de linhas não são adicionados, por isso é normal que cada uma das linhas fornecidas tenha um separador de linha no final.</li>
            </ul>
            <h4>Outros métodos interessantes</h4>
            <ul>
                <li><code>seek(offset, whence=os.SEEK_SET, /)</code>: Avança ou retrocede, dependendo de whence, a posição do fluxo em offset bytes, e retorne a nova posição absoluta. Os valores de whence são:
                    <ul>
                        <li><code>os.SEEK_SET</code>: Início do fluxo (padrão); offset pode ser zero ou positivo.</li>
                        <li><code>os.SEEK_CUR</code>: Posição atual do fluxo; offset pode ser negativo..</li>
                        <li><code>os.SEEK_END</code>: Final do fluxo; ofsset geralmente é negativo.</li>
                    </ul>
                </li>
                <li><code>readable()</code>: Retorna True se o fluxo puder ser lido. Se for falso, read() gerará OSError.</li>
                <li><code>seekable()</code>: Retorna True se o fluxo suportar acesso aleatório. Se for falso, seek(), tell() e truncate() gerarão OSError.</li>
                <li><code>tell()</code>: Retorna a posição atual do fluxo.</li>
                <li><code>writable()</code>: Retorna True se o fluxo suportar escrita. Se for False, write() e truncate() gerarão OSError.</li>
                <li><code>encoding</code>: Não é um método, é um atributo que contém o nome da codificação usada para decodificar os bytes do fluxo em strings e para codificar strings em bytes.</li>
            </ul>
            <p>Por fim, temos o método <code>close</code>, que sempre deve ser invocado após terminarmos de mexer com arquivo. Esse método garante que as modificações sejam salvas no disco e que todos os recursos associados ao arquivo sejam liberados de volta para o sistema operacional. Tecnicamente, isso acontece automaticamente quando o script é encerrado, mas é melhor ser explícito e fecharmos nós mesmos, especialmente em processos de longa execução.</p>
        </div>
        <div id="7-1-5-placing-it-in-context">
            <h3>Contextualizando</h3>
            <p>Como trabalhar com arquivos não depende apenas dos códigos que escrevemos, mas do sistema operacional, podem ocorrer exceções. Por isso, quando trabalhamos com arquivos, podemos envolvemos tudo dentro de cláusulas <code>try-except-finally</code> para fazer as devidas tratativas e garantir que o arquivo é fechado e nenhum trabalho seja perdido. Outra maneira mais prática é usar a instrução <code>with-as</code>, que encapsula operações comuns como o método <code>close</code>, sem explicitamente invocá-lo:</p>
            <pre><code>with open('filename') as file:
    for line in file:
        print(line, end='')</code></pre>
            <p>O objeto criado pela função <code>open</code> é atribuído à variável <code>file</code>, e ao final do bloco do <code>with</code>, é automaticamente fechado, mesmo que ocorra uma exceção.</p>
            <p>A instrução <code>with-as</code> funciona com qualquer objeto que implemente os métodos mágicos <code>__enter__</code> e <code>__exit__</code>. Esses métodos indicam para o Python como se deve inicializar um recurso e como finalizá-lo após seu uso, mesmo quando ocorre uma exceção. Objetos que implementam esses métodos são chamados de <b>gerenciadores de contexto</b> (<b>context manager</b>).</p>
            <p>Outro exemplo de gerenciador de contexto no Python é o objeto retornado pela função <code>urllib.request.urlopen</code>, usado para ler o conteúdo de uma página:</p>
            <pre><code>import urllib.request
with urllib.request.urlopen('https://www.example.com/') as response:
   html = response.read()
print(html)</code></pre>
            <p>Após o término do <code>with-as</code>, a conexão com o socket é encerrada.</p>
            <p>Para ilustrar como seria a implementação de um gerenciador de contexto, suponha que queiramos implementar uma classe de objetos que se conecta a um banco de dados:</p>
            <pre><code>class DatabaseConnection(object):

    def __enter__(self):
        # make a database connection and return it
        ...
        return self.dbconn

    def __exit__(self, exc_type, exc_val, exc_tb):
        # make sure the dbconnection gets closed
        self.dbconn.close()
        ...</code></pre>

            <p>O método <code>__enter__</code> se encarrega de abrir a conexão com o banco de dados, e o método <code>__exit__</code> se encarrega de fechá-la. Caso ocorra alguma exceção, o método <code>__exit__</code> é invocado com as informações da exceção nos parâmetros exc_type, exc_val e exc_tb.</p>
        </div>
        <h3>Exercícios</h3>
        <ol class="excs">
            <li>Ler um caminho para um arquivo de texto e escrever o conteúdo do arquivo.</li>
            <li>Ler um caminho para um novo arquivo de texto e o conteúdo a ser salvo neste arquivo de texto, até encontrar um EOF. Caso o usuário informe um caminho para um arquivo existente, avisá-lo, e encerrar o programa.</li>
            <li>Ler um caminho para um arquivo de texto e escrever quantas palavras ele possui.</li>
            <li>Ler um caminho para um arquivo de texto e uma palavra-chave. Escrever quantas vezes a palavra-chave ocorre.</li>
            <li>Em um arquivo CSV cada linha representa um registro; e cada coluna, separada uma das outras por vírgula, representa o valor de uma propriedade daquele registro. A primeira linha de um arquivo CSV geralmente é o cabeçalho, que vem com os nomes das propriedades dos registros, isto é, não representa um registro. Ler um caminho para um arquivo CSV, cuja primeira linha contém o cabeçalho. Ler um número de linha. Escrever o conteúdo do registro daquela linha específica do arquivo, apresentando cada propriedade em uma linha separada, da seguinte forma: "nome da propriedade: valor da propriedade".</li>
            <li>Ler um caminho para um novo arquivo CSV e o nome, idade e cidade de várias pessoas, até encontrar um EOF. Caso o arquivo não exista, salvar as informações das pessoas nesse arquivo CSV. (Considerar que os valores informados não possuam vírgula, que é usado como separados das propriedades).</li>
        </ol>
    </div>
    <div id="7-2-an-alternative-to-method-overloading">
        <h2>Uma alternativa a sobrecarga de métodos</h2>
        <p>Sobrecarga de métodos e funções é quando temos vários métodos (ou funções) com o mesmo nome, mas com diferentes tipos e quantidades de parâmetros. Um exemplo de utilização pode ser um método que envia email para um contato padrão e outro método que envia email para um contato passado como argumento. Ambos podem ter o mesmo nome. O Python não implementa sobrecarga de métodos, mas alcança funcionalidades semelhantes usando valores padrão para os parâmetros ou usando argumentos arbitrários, como <code>*args</code> e <code>**kwargs</code>.</p>

        <h3>Argumentos padrão</h3>
        <p>Para tornar um parâmetro opcional, atribua um valor padrão na sua declaração. Se o invocador da função não especificar um argumento para esse parâmetro, ele é inicializado com o valor padrão:</p>
        <pre><code>def default_arguments(x, y, z, a="String", b=False):
    print("Meus argumentos são", x, y, z, a, b)</code></pre>
        <p>Os primeiros três parâmetros dessa função são obrigatórios, mas os dois últimos são opcionais, e se não informados, começam com os valores atribuídos a eles na declaração.</p>
        <p>Podemos invocar a função de várias formas. Passando apenas os argumentos obrigatórios:</p>
        <pre><code># passando apenas argumentos obrigatórios
default_arguments(1,2,3)

# passando todos os argumentos
default_arguments(4,5,6,7,8)

# passando os argumentos em ordens diferentes
default_arguments(y=10,x=9,z=11,b=True)</code></pre>

        <p>Por padrão, os parâmetros podem ser <b>posicionais</b> (<i>positional parameters</i>) ou <b>nominais</b> (<i>keyword parameters</i>). Os argumentos de parâmetros posicionais são passados na ordem em que os parâmetros foram declarados. Já os argumentos de parâmetros nominais (parâmetros com palavra-chave) são passados informando o nome dos respectivos parâmetros. Você também pode especificar quais argumentos só podem ser passados posicionalmente ou nominalmente.</p>
        <p>Para indicar quais argumentos só podem ser passados nominalmente, coloque um <code>*</code> antes de seus parâmetros:</p>
        <pre><code>def kw_only(x, y='defaultkw', *, a, b='only'):
    print(x, y, a, b)</code></pre>
        <p>Os argumentos de <code>x</code> e <code>y</code> podem ser passados posicionalmente ou nominalmente, mas os argumentos de <code>a</code> e <code>b</code>, que estão depois do <code>*</code>, só podem ser passados nominalmente.</p>
        <p>Ocorre uma exceção se não informar o argumento obrigatório <code>a:</code></p>
        <pre><code>>>> kw_only('x')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: kw_only() missing 1 required keyword-only argument: 'a'</code></pre>
        <p>Também ocorre exceção se tentar passar <code>a</code> como posicional:</p>
        <pre><code>>>> kw_only('x', 'y', 'a')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: kw_only() takes from 1 to 2 positional arguments but 3 were given</code></pre>
        <p>Para indicar quais argumentos só podem ser passados posicionalmente, coloque uma <code>/</code> depois de seus parâmetros:</p>
        <pre><code>def pos_only(x, y, /, a, b='only'):
    print(x, y, a, b)</code></pre>
        <p>Os argumentos de <code>x</code> e <code>y</code>, que estão antes da <code>/</code>, não podem ser passados nominalmente, mas os argumentos de <code>a</code> e <code>b</code>, sim.</p>
        <p>Agora você não pode mais inverter a ordem de <code>x</code> e <code>y</code>:</p>
        <pre><code>>>> pos_only(y='y',x='x','a','b')
Traceback (most recent call last):
        File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument</code></pre>

        <p>Veja <a href="https://stackoverflow.com/a/57819001/4072641">diferentes exemplos</a> de parâmetros posicionais e parâmetros nominais:</p>
        <li>Parâmetro obrigatório somente posicional:</li>
        <pre><code>def f(a, /):
    pass

f()  # error, argument is required
f(1)  # allowed, positional argument
f(a=1)  # error, keyword argument</code></pre>
        <li>Parâmetro opcional somente posicional:</li>
        <pre><code>def f(a=2, /):
    pass

f()  # allowed, argument is optional
f(1)  # allowed, positional argument
f(a=1)  # error, keyword argument</code></pre>
        <li>Parâmetro obrigatório somente nominal</li>
        <pre><code>def f(*, a):
    pass

f()  # error, argument is required
f(1)  # error, positional argument
f(a=1)  # allowed, keyword argument</code></pre>
        <li>Parâmetro opcional somente nominal</li>
        <pre><code>def f(*, a=1):
    pass

f()  # allowed, argument is optional
f(1)  # error, positional argument
f(a=1)  # allowed, keyword argument</code></pre>
        <li>Parâmetro obrigatório</li>
        <pre><code>def f(a):
    pass

f()  # error, argument is required
f(1)  # allowed, positional argument
f(a=1)  # allowed, keyword argument</code></pre>
        <li>Parâmetro opcional</li>
        <pre><code>def f(a=1):
    pass

f()  # allowed, argument is optional
f(1)  # allowed, positional argument
f(a=1)  # allowed, keyword argument</code></pre>

        <p>O propósito desses recursos de parâmetros somente posicionais e somente nominais é implementar APIs que restrinjam o que os clientes podem fazer, seja para deixar o código mais claro, ou menos suscetível a erros. Por exemplo, você pode estar desenvolvendo uma API que ainda não tem os nomes dos parâmetros muito bem definidos, e que estejam <a href="https://stackoverflow.com/a/76010989/4072641">suscetíveis a mudanças</a>:</p>
        <pre><code>def pow(base, exponet):
   pass</code></pre>
        <p>Suponha que um código cliente utilize sua API:</p>
        <pre><code>pow(4.5, 10)
pow(4.5, exponet=10)
pow(exponet=10, base=4.5)</code></pre>
        <p>Se futuramente você mudar tua API, muitos códigos clientes podem quebrar:</p>
        <pre><code>def pow(base, exp)
   pass</code></pre>
        <p>Você poderia ter evitado todo esse transtorno obrigando os clientes a não usar tua API de determinada forma:</p>
        <pre><code>def pow(base, exponent, /)
    pass</code></pre>
        <p>Por exemplo, observe o cabeçalho da <a href="https://docs.python.org/3/library/functions.html#sorted">função incorporada <code>sorted</code></a>:</p>
        <pre><code>sorted(iterable, /, *, key=None, reverse=False)</code></pre>
        <p>O primeiro parâmetro é somente posicional, e os demais são somente nominais.</p>
        <!-- One thing to take note of with keyword arguments is that anything we provide... [essa parte eu não falei] -->

        <h3>Lista de argumentos variável</h3>
        <p>No Python, uma função pode receber uma quantidade arbitrária de argumentos sem ter que declarar um parâmetro para cada argumento. Esse recurso é chamado de <b>varargs</b>, de <i>variadic arguments</i> (ou simplesmente <code>*args</code>), presente em muitas linguagens de programação. Por exemplo, você pode ter uma função que processa um link ou uma lista de links como argumento:</p>
        <pre><code>def get_pages(*links):
    for link in links:
        #download the link with urllib
        print(link)
    print()</code></pre>
        <p>O asterisco no início do parâmetro indica que este recebe um ou vários argumentos:</p>
        <pre><code>>>> get_pages()
>>> get_pages("http://www.archlinux.org")
http://www.archlinux.org
>>> get_pages("http://www.archlinux.org", "http://mxlinux.org/", "http://q4os.org/")
http://www.archlinux.org http://mxlinux.org/ http://q4os.org/</code></pre>

        <p>Os argumentos são apenas posicionais. Se quisermos, podemos aceitar argumentos apenas nominais, usando dois asteriscos em vez de um. Neste caso, o parâmetro é um dicionário, e não uma lista:</p>
        <pre><code>>>> def print_keyword_args(**kwargs):
...     # kwargs is a dict of the keyword args passed to the function
...     for key, value in kwargs.items():
...         print(key, "=", value)
...
>>> print_keyword_args(first_name="John", last_name="Doe")
first_name = John
last_name = Doe</code></pre>
        <!-- Não dei o exemplo da classe Options do livro, nem falei dos perigos de kwargs do parágrafo The keyword argument syntax can be dangerous... -->
        <p>Esses argumentos variados com palavra-chave são conhecidos como <b>**kwargs</b>. Uma aplicação deles é quando temos uma função que aceita argumentos arbitrários que são passados para uma segunda função, mas não sabemos de antemão quais serão esses argumetos.</p>
        <p>Considere o seguinte problema: queremos transferir uma lista de arquivos para uma pasta destino. A opção padrão é mover, mas podemos passar opções diferentes para cada arquivo, como ignorar algum ou copiá-lo em vez de movê-lo. O seguinte exemplo ilustra os diferentes tipos de parâmetros que vimos para resolver esse problema:</p>
        <pre><code>import shutil
import os.path

def augmented_move(target_folder, *filenames, verbose=False, **specific):
    """Move all filenames into the target_folder, allowing specific treatment of certain files."""

    def print_verbose(message, filename):
        """print the message only if verbose is enabled"""
        if verbose:
            print(message, filename)

    for filename in filenames:
        target_path = os.path.join(target_folder, filename)
        if filename in specific:
            if specific[filename] == "ignore":
                print_verbose("Ignoring", filename)
            elif specific[filename] == "copy":
                print_verbose("Copying", filename)
                shutil.copyfile(filename, target_path)
        else:
            print_verbose("Moving", filename)
            shutil.move(filename, target_path)</code></pre>
        <p>O primeiro parâmetro é a pasta destino. O segundo parâmetro é uma lista de arquivos que serão movidos para a pasta destino. O terceiro parâmetro indica se deve ser informado ao usuário o estado do processamento. O último parâmetro contém as ações específicas a serem tomadas para determinados arquivos.</p>
        <p>Veja exemplos de invocações a essa função:</p>
        <pre><code>>>> augmented_move("move_here", "one", "two")
>>> augmented_move("move_here", "three", verbose=True)
Moving three
>>> augmented_move("move_here", "four", "five", "six", four="copy", five="ignore")
>>> augmented_move("move_here", "seven", "eight", "nine", seven="copy", verbose=True, eight="ignore")
Copying seven
Ignoring eight
Moving nine</code></pre>

        <p>Um exemplo de <code>**kwargs</code> no Python é na inicialização de dicionários. As seguintes linhas são equivalentes:</p>
        <pre><code>d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
d = dict(a=1, b=2, c=3, d=4)</code></pre>
        <p>Um exemplo de <code>*args</code> no Python é a função <code>print</code>. Observe seu cabeçalho:</p>
        <pre><code>print(*args, sep=' ', end='\n', file=None, flush=False)</code></pre>
        <p>O método <code>format</code> da classe <code>str</code> aceita tanto um <code>*args</code> quanto um <code>**kwargs</code> como argumento:</p>
        <pre><code>names = ["Bob", "John"]
conditions = ["good", "ok"]

s1 = "Hello, {}, are you {}?".format(names[0], conditions[0])
s2 = "Hello, {name}, are you {condition}?".format(condition=conditions[1], name=names[1])

print(s1)
print(s2)</code></pre>

        <p>Antes do Python 3.6, se quiséssemos formatar uma string, recorríamos ao método <code>format</code>. Mas agora podemos usar diretamente interpolação de strings, conhecida como f-string:</p>
        <pre><code>s1 = f"Hello, {names[0]}, are you {conditions[0]}?"
s2 = f"Hello, {names[1]}, are you {conditions[1]}?"</code></pre>

        <h3>Desempacotando argumentos</h3>
        <p>Vimos como tratar diversos argumentos como um único parâmetro. Mas e o contrário, podemos tratar um único argumento como diversos parâmetros? Sim, com expansão, também chamado de desempacotamento (unpacking), ou destruturação (destructuring):</p>
        <pre><code>def show_args(a, b, c="Default"):
    print(a, b, c)

a_list = [1, 2]
a_dict = {"b": 1, "c": 2, "a": 3}

show_args(*a_list)
show_args(**a_dict)</code></pre>

        <p>Desempacotamento também funciona fora de funções:</p>
        <pre><code>l = [1, 2]
d = {"a": 1, "b": 2, "c": 3}

# os itens de `l` foram desempacotados e inseridos em `ll`
ll = [0, *l, 3]
print(ll)

# os itens de `d` foram desempacotados e inseridos em `dd`
dd = {"x": 4, **d, "y": 5}
print(dd)

# os dois primeiros itens de `ll` foram desempacotados nas variáveis `first` e `second`,
#  os demais itens foram desempacotados na lista `_`
first, second, *_ = ll
print(first, second)

# o primeiro e o último item de `ll` foram desempacotados nas variáveis `first` e `last`,
#  os demais itens foram desempacotados na lista `_`
first, *_, last = ll
print(first, last)

# apenas as chaves são desempacotadas...
key1, key2, *_ = dd
print(dd[key1], dd[key2])</code></pre>

        <!-- 



https://realpython.com/python-iterators-iterables/#unpacking-iterables



-->

        <p>Você pode ler mais a respeito de <a href="https://realpython.com/python-kwargs-and-args/"><code>*args</code> e <code>**kwargs</code> aqui</a>.</p>

        <h3>Exercícios</h3>
        <ol class="excs">
            <h4>Implementar as seguintes funções:</h4>
            <li><code>soma_numeros</code>: Recebe uma quantidade arbitrária de números como argumentos posicionais. Retorna a soma de todos os números passados como argumentos.</li>
            <li><code>media_valores</code>: Recebe uma quantidade arbitrária de números como argumentos posicionais. Retorna a média de todos os números passados como argumentos.</li>
            <li><code>concatena_strings</code>: recebe uma string inicial e uma quantidade arbitrária de outras strings como argumentos posicionais. Retorna a concatenação de todas as strings recebidas.</li>
            <li><code>juncao_listas</code>: Recebe uma quantidade arbitrária de listas como argumentos posicionais. Retorna uma única lista contendo todos os elementos das listas recebidas.</li>
            <li><code>formata_string</code>: Sua própria versão de str.format, que recebe uma string de entrada com <i>placeholders</i> delimitados por chaves <code>{}</code>, e uma quantidade arbitrária de argumentos nominais (<code>**kwargs</code>). Os <i>placeholders</i> na string de entrada devem corresponder às chaves nos argumentos nominais. Retorna a string de entrada onde cada <i>placeholder</i> é substituído pelo valor da string do argumento correspondente.</li>
        </ol>
    </div>
    <div id="7-3-functions-are-objects-too">
        <h2>Funções como objetos</h2>

        <p>Uma função <i>callback</i> é uma função que é passada como argumento para outra função. A função que recebe a função callback pode então invocá-la quando certas condições são atendidas ou quando um evento ocorre.</p>
        <p>A seguinte função invoca a função callback após um tempo de espera:</p>
        <pre><code>import time

def call_after(delay, callback, **kwargs):
    time.sleep(delay)
    callback(**kwargs)</code></pre>
        <p>O legal é que se a função callback precisar de argumentos para ser executada, podemos receber uma quantidade arbitrária de argumentos pelo parâmetro <code>**kwargs</code>, e repassá-los à callback!</p>
        <p>Vamos declarar algumas funções e invocá-las através da função <code>call_after</code>:</p>
        <pre><code>from datetime import datetime

def format_time(message):
    print(datetime.now(), message)

def nothing():
    format_time("I do nothing")

def sum(a, b):
    format_time(f"Sum: {a}+{b}={a+b}")

def greetings(name=None):
    format_time(f"Hello, {name if name else 'world'}!" )

format_time("Valendo!")
call_after(3, nothing)
call_after(2, sum, a=4, b=3)
call_after(1, greetings, name="Pedro")</code></pre>
        <p>Observe que uma função só é executada após o término da anterior.</p>
        <p>Também podemos usar métodos de objetos como callbacks:</p>
        <pre><code>class Repeater:
    def __init__(self, times=3, delay=1):
        self.count = 0
        self.times = times
        self.delay = delay

    def repeat(self):
        format_time(f"repeat {self.count}")
        self.count += 1
        if self.count &lt; self.times:
            call_after(self.delay, self.repeat)

format_time("Valendo!")
repeater = Repeater()
call_after(4, repeater.repeat)</code></pre>
        <p>Funções callback são muito úteis em situações onde você não deseja que a execução do programa seja bloqueada, aguardando a ocorrência de eventos específicos ou a conclusão de operações demoradas. Em casos como o da função <code>call_after</code>, cuja execução pode ser consideravelmente prolongada devido ao seu parâmetro <code>delay</code>, podemos usar o objeto <code>ThreadPoolExecutor</code> para executar funções em paralelo:</p>

        <pre><code>from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor() as executor:
    format_time("Valendo!")
    executor.submit(call_after, 3, nothing)
    executor.submit(call_after, 2, sum, a=4, b=3)
    executor.submit(call_after, 1, greetings, name="Pedro")
    repeater = Repeater()
    executor.submit(call_after, 4, repeater.repeat)</code></pre>
        <p>O método <code>submit</code> recebe três argumentos, a função <code>fn</code> a ser invocada, uma sequência de argumentos posicionais <code>*args</code>, e uma sequência de argumentos nominais <code>**kwargs</code>. O método, então, executa a função como <code>fn(*args, **kwargs)</code>. Não precisa se preocupar em entender o objeto <code>ThreadPoolExecutor</code> e seus métodos. O Capítulo 13 aborda especificamente esse assunto de concorrência e paralelismo em Python. Esse exemplo é mais para ilustrar o funcionamento de callbacks.</p>

        <h3>Usando funções como atributos</h3>
        <p>Devido à dinamicidade do Python, é possível até atribuir uma função como método de um objeto, após ele ser instanciado:</p>
        <pre><code>class A:
    def print(self):
        print("my class is A")

def fake_print():
    print("my class is not A")

a = A()
a.print()
a.print = fake_print
a.print()</code></pre>
        <p>É possível substituir métodos em classes, em vez de objetos, adicionando o argumento <code>self</code> à lista de parâmetros. Isso alterará o método para todas as instâncias daquela classe, mesmo as que já foram criadas. No entanto, substituir métodos dessa maneira pode ser perigoso e confuso de manter. Isso porque pode causar confusão durante a leitura do código, levando a sessões de depuração complicadas e frustrantes.</p>
        <p>Substituir ou adicionar métodos em tempo de execução é chamado de <b>monkey patching</b>. Seus casos de uso incluem, especialmente em testes automatizados. Por exemplo, pode ser usado para simular comportamentos de rede sem realmente se conectar a um servidor. Também pode ser útil para corrigir bugs ou adicionar funcionalidades em código de terceiros. No entanto, deve ser usado com cuidado, pois geralmente é uma solução pouco elegante e pode causar confusão no código.</p>

        <h3>Objetos invocáveis</h3>
        <p>Tudo é objeto em Python. Portanto, uma função é um objeto que possui atributos. Se você passar uma função como argumento à função <code>dir</code>, verá seus atributos e métodos. Por exemplo, dentre os métodos do "objeto" <code>print</code>, há o <code>__call__</code>.</p>
        <pre><code>>>> dir(print)
['__call__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__text_signature__']</code></pre>

        <p>Toda função é um objeto que tem implementado o método <code>__call__</code>. Objetos que implementam <code>__call__</code> são conhecidos como objetos invocáveis (callable). E um objeto invocável é aquele que você pode invocar, como uma função, usando parênteses. Você pode saber se um objeto é invocável através da função incorporada <code>callable</code>, que retorna um booleano:</p>
        <pre><code>>>> callable(print) # uma função
True
>>> callable(dict) # uma classe
True
>>> callable(dict()) # um objeto
False</code></pre>
        <p>Observe que a classe <code>dict</code> é invocável, enquanto que um objeto da classe <code>dict</code> não é invocável.</p>
        <p>Ao declarar uma função, nos bastidores, o Python está instanciando um objeto com o método <code>__call__</code> com as instruções que você implementou na função:</p>
        <pre><code>def uma_funcao(um_parametro, outro_parametro):
    print("uma instrução qualquer")
    print(um_parametro, outro_parametro)

uma_funcao(12, 34)
uma_funcao.__call__(12, 34)</code></pre>

        <p>Suponha que queiramos calcular a média de números provindos de diferentes fontes. No <a href="https://realpython.com/python-callable-instances/">seguinte exemplo</a>, implementamos uma classe para instanciar objetos que se comportam como funções para realizar essa tarefa.</p>
        <pre><code>class CumulativeAverager:
    def __init__(self):
        self.data = []

    def __call__(self, new_value):
        self.data.append(new_value)
        return sum(self.data) / len(self.data)</code></pre>

        <p>Agora podemos instanciar objetos que simulam funções que calculam a média enquanto mantêm os valores calculados:</p>
        <pre><code>>>> file_stream_average = CumulativeAverager()
>>> url_stream_average = CumulativeAverager()
>>>
>>> file_stream_average(12)
12.0
>>> file_stream_average(13)
12.5
>>> file_stream_average(11)
12.0
>>> file_stream_average(10)
11.5
>>>
>>> url_stream_average(.34)
0.34
>>> url_stream_average(.71)
0.525
>>> url_stream_average(.39)
0.48
>>>
>>> file_stream_average.data
[12, 13, 11, 10]
>>> url_stream_average.data
[0.34, 0.71, 0.39]</code></pre>

        <p>Exótico, curioso, intrigante. Devido à filosofia "transparente", o Python te permite ver e até mesmo alterar muita coisa que acontece nos bastidores. Mas isso não quer dizer que você deva se embrenhar nesse mundo de variáveis mágicas.</p>
    </div>

    <div id="7-4-case-study">
        <h2>Estudo de caso</h2>
        <p>Para amarrar alguns dos princípios estudados em um único exemplo, vamos construir um gerenciador de grupos de emails. O gerenciador categorizará os endereços de email em grupos. Ao enviar um email, podemos escolher um endereço de email, uma lista de endereços de email, ou um grupo pré-salvo de endereços de email.</p>

        <h3>API de envio de email</h3>
        <p>Nosso gerenciador se utilizará da seguinte API que se conecta a um servidor Simple Mail Transfer Protocol (SMTP) para enviar email:</p>
        <pre><code>import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


def send_email(subject, body, from_addr, *to_addrs, host="localhost", port=1025):
    msg = MIMEMultipart()
    msg["From"] = from_addr
    msg["To"] = ", ".join(to_addrs)  # Join the recipients with a comma and space
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))

    with smtplib.SMTP(host, port) as server:
        server.sendmail(from_addr, to_addrs, msg.as_string())
        print("Sent!")</code></pre>

        <p>Com sua vasta biblioteca, o Python já fornece o módulo <code>email</code> para criar emails e o módulo <code>smtplib</code> para se conectar a um servidor SMTP e enviar o email. Como os detalhes dessa API fogem do escopo do estudo de caso proposto, vamos poupar a explicação desse código. Basta saber o quê a função faz: envia uma mensagem para uma lista de endereços de email usando um servidor SMTP rodando no endereço <code>host:port</code>. Se quiser saber mais, pode consultar a documentação oficial.</p>
        <p>O legal é que o Python também vem com um servidor SMTP instalado. Você pode iniciá-lo no modo "debugging", que em vez de enviar o email, simplesmente o imprime no terminal. Se quiser de fato enviar um email, precisaria configurar a API para se conectar a uma conta de email e alterar os parâmetros de inicialização do servidor SMTP. Este artigo trás informações de <a href="https://realpython.com/python-send-email/">como conectar um SMTP</a> a uma conta de email.</p>
        <p>Abra um terminal e inicie o servidor SMTP:</p>
        <pre><code>python -m smtpd -n -c DebuggingServer localhost:1025</code></pre>
        <p>Para testar se a API está funcionando, abra outro terminal, execute a API no modo interativo (<code>-i</code>) e envie um email de teste:</p>
        <pre><code>>>> send_email("A Party", "Friends and family only: a party", "me@example.com", "friend1@example.com", "family1@example.com")
Sent!</code></pre>
        <p>Verifique no terminal rodando o servidor SMTP se ele recebeu a requisição de email:</p>
        <pre>---------- MESSAGE FOLLOWS ----------
b'Content-Type: multipart/mixed; boundary="===============2472709131490945134=="'
b'MIME-Version: 1.0'
b'From: me@example.com'
b'To: friend1@example.com, family1@example.com'
b'Subject: A Party'
b'X-Peer: ::1'
b''
b'--===============2472709131490945134=='
b'Content-Type: text/plain; charset="us-ascii"'
b'MIME-Version: 1.0'
b'Content-Transfer-Encoding: 7bit'
b''
b'Friends and family only: a party'
b'--===============2472709131490945134==--'
------------ END MESSAGE ------------</pre>

        <h3>Nosso gerenciador de grupos de emails</h3>
        <p>Agora sua tarefa é implementar a API do gerenciador de grupos de email. Sua interface deve ser a seguinte:</p>
        <pre><code>class MailingList:
    """Gerencia grupos de endereços de email para enviar emails."""

    def __init__(self, data_file):
        """
        Inicializa uma instância da classe MailingList.

        Args:
            data_file (str): O caminho do arquivo de dados que armazena as informações do grupo de email.
        """
        pass

    def add_to_group(self, email, group):
        """
        Adiciona um endereço de email a um grupo específico. Se o endereço ou grupo não existir, criá-lo.

        Args:
            email (str): O endereço de email a ser adicionado.
            group (str): O nome do grupo ao qual o email será adicionado.
        """
        pass

    def emails_in_groups(self, *groups):
        """
        Retorna os endereços de email pertencentes a um ou mais grupos especificados.

        Args:
            *groups (str): Argumentos variáveis representando os nomes dos grupos.

        Returns:
            set: Um conjunto contendo os endereços de email pertencentes aos grupos especificados.
        """
        pass

    def send_mailing(self, subject, message, from_addr, emails, groups):
        """
        Envia um email para todos os endereços no conjunto `emails` e todos os endereços membros dos grupos no conjunto `groups`.

        Args:
            subject (str): O assunto do email.
            message (str): O corpo do email.
            from_addr (str): O endereço de email do remetente.
            emails (set): Conjunto de strings representando endereços de email.
            groups (set): Conjunto de strings representando grupos de email.
        """
        pass

    def __enter__(self):
        """
        Método de entrada do gerenciador de contexto usado para carregar os dados do arquivo.
        """
        pass

    def __exit__(self, type, value, tb):
        """
        Método de saída do gerenciador de contexto usado para salvar os dados no arquivo.
        """
        pass</code></pre>

        <p>Na instanciação (método <code>__init__</code>) é passado o caminho para o arquivo de texto <code>data_file</code> que contém os grupos e endereços de email cadastrados. O relacionamento entre os endereços e seus grupos é de muitos-para-muitos, pois um endereço pode estar em vários grupos, e um grupo pode ter vários endereços. Como você representará esse relacionamento em um arquivo de texto, fica a teu critério. Uma possibilidade é cada linha do arquivo de texto começar com o nome do grupo, seguido por todos os endereços daquele grupo. Mas como cada linha do arquivo separará os grupos dos endereços? Por espaço? E se o nome do grupo puder ter espaços também? Por simplicidade, podemos assumir que os nomes dos grupos serão compostos apenas por letras minúsculas.</p>
        <p>Como trabalharemos com leitura e escrita de arquivos, a classe <code>MailingList</code> é gerenciadora de contexto, para garantir a abertura e fechamento do arquivo mesmo em caso de exceção, através dos métodos <code>__enter__</code> e <code>__exit__</code>. Como ler e, principalmente, escrever, em arquivos é uma tarefa custosa, vamos lê-lo apenas uma vez dentro do método <code>__enter__</code>, e escrevê-lo apenas uma vez dentro do método <code>__exit__</code>. Mas como carregaremos os dados do arquivo em nosso objeto? Podemos ter um atributo dicionário em que as chaves são os emails, e os valores são os grupos a que cada email pertence.</p>
        <p>Observe que estamos trabalhando com arquivos gerenciados por nós mesmos. Poderíamos utilizar um sistema de bancos de dados existente para carregar e armazenar os endereços e grupos de email. Mas para fins didáticos e de treinamento, vamos fazer tudo "na unha".</p>
        <p>Outra questão a considerar é, ao carregar os dados do arquivo, ou adicionar um endereço de email ou grupo, vamos fazer validação? Se sim, como? Por exemplo, como o arquivo separa os endereços por espaço, e se alguém passar uma string contendo vários endereços de email separados por espaço, numa tentativa de "ataque de injeção"? Ou então simplesmente passar um endereço de email inválido? Existem várias situações que poderíamos encontrar durante a validação. Poderíamos usar bibliotecas de validação de dados em vez de desenvolver soluções do zero. Novamente, para fins educacionais, podemos desenvolver uma validação de dados com tratamento de exceção, tentando levantar possíveis situações inválidas que podem surgir.</p>
        <p>Por fim, como nossa API se utilizará da API fornecida na seção anterior, que conecta ao servidor SMTP e envia o email, será no método <code>send_mailing</code> da nossa classe que invocaremos a função <code>send_email</code> da API fornecida.</p>
        <!--<pre><code>import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


def send_email(subject, body, from_addr, *to_addrs, host="localhost", port=1025):
    msg = MIMEMultipart()
    msg["From"] = from_addr
    msg["To"] = ", ".join(to_addrs)  # Join the recipients with a comma and space
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))

    with smtplib.SMTP(host, port) as server:
        server.sendmail(from_addr, to_addrs, msg.as_string())
        print("Sent!")


class MailingList:
    """Gerencia grupos de endereços de email para enviar emails."""

    def __init__(self, data_file):
        """
        Inicializa uma instância da classe MailingList.

        Args:
            data_file (str): O caminho do arquivo de dados que armazena as informações do grupo de email.
        """
        self.data_file = data_file
        self.email_map = defaultdict(set)

    def add_to_group(self, email, group):
        """
        Adiciona um endereço de email a um grupo específico.

        Args:
            email (str): O endereço de email a ser adicionado.
            group (str): O nome do grupo ao qual o email será adicionado.
        """
        self.email_map[email].add(group)

    def emails_in_groups(self, *groups):
        """
        Retorna os endereços de email pertencentes a um ou mais grupos especificados.

        Args:
            *groups (str): Argumentos variáveis representando os nomes dos grupos.

        Returns:
            set: Um conjunto contendo os endereços de email pertencentes aos grupos especificados.
        """
        groups = set(groups)
        emails = set()
        for e, g in self.email_map.items():
            if g & groups:
                emails.add(e)
        return emails

    def send_mailing(self, subject, message, from_addr, emails, groups):
        """
        Envia um email para todos os endereços em `emails` e todos os endereços membros dos grupos em `groups`.

        Args:
            subject (str): O assunto do email.
            message (str): O corpo do email.
            from_addr (str): O endereço de email do remetente.
            *groups (str): Argumentos variáveis representando os nomes dos grupos.
        """
        emails = self.emails_in_groups(*groups)
        send_email(subject, message, from_addr, *emails)

    def __enter__(self):
        """
        Método de entrada do gerenciador de contexto usado para inicializar a classe e carregar os dados do arquivo.
        """
        self.email_map = defaultdict(set)
        with suppress(IOError):
            with open(self.data_file) as file:
                for line in file:
                    email, groups = line.strip().split(" ")
                    groups = set(groups.split(","))
                    self.email_map[email] = groups
        return self

    def __exit__(self, type, value, tb):
        """
        Método de saída do gerenciador de contexto usado para salvar os dados da instância de classe no arquivo.
        """
        with open(self.data_file, "w") as file:
            for email, groups in self.email_map.items():
                file.write("{} {}\n".format(email, ",".join(groups)))</code></pre>-->
    </div>
    <div id="7-5-exercises">
        <h2>Exercícios</h2>
        <ol class="excs">
            <li>Implemente um cliente que utiliza a API <code>MailingList</code> do estudo de caso.</li>
        </ol>
    </div>
</div>
<!-- Colocar mais exercícios -->