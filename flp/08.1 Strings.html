<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            document.getElementById("string-indexes").src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAiUAAABoCAYAAAAuNIBwAAAABHNCSVQICAgIfAhkiAAAIABJREFUeF7tfQ9wHNWZ59fhj4eFOg/JHRonm2iyKU5j2KyGvU1pqPyxckA8uaRO41yB5YQguW53rSx3WFxILNitwlspYrlgV2KPC4bNlsdkOQlnE40vCZYPcpYTCo9TEA1ZQOOQOw/UgcbJ3krskrIcbPq+r/93T/dopmf6dWv8vXJ7NK973vve7/vzvvfe915LsiwDJ0aAEWAEGAFGgBFgBMJG4F1hE8D1MwKMACPACDACjAAjQAiwU8JywAgwAowAI8AIMAKRQICdkkiwgYlgBBgBRoARYAQYAXZKWAYYAUaAEWAEGAFGIBIIsFMSCTYwEYwAI8AIMAKMACPATgnLACPACDACjAAjwAhEAoH2OyUPSAVJkuRGrlxBMAbfltJ/+gmpmIwZ9K0gnURvXCwlUi7XGEYpsXQ5a5NSYykDq/Gy83bg36XYkT+UJn/3fVI1ZuJFPCvila4GXr9LBXmp/6spqZSwy1AJ6cmVV1yeF5l1WBrNqDiVx8QzS2RLG6/rB9J4qjFdI5slXN+euVsav+lD0rJFvitIx2Cl8Ra25clCriGbHYINsDeviv1LXOOn8P4DSTlxhzTa/9tSJW7qP8lNiPovxZ7+T9K+a99tk6Eq0rQPr0RbhMN3IVJyMmPIVeO6ReeUtPX6OuzDNlB/4XmtA6DDUeStM22uu15bvgWjfevVenXa4nGgboRoWcYr3lYc6tEiw+CAWi/V74kT3kuKo6mWF/O3AXVtCq/wGl+o26ba37dGO6TGr1H4otev4GThmXiavg/jPSY9RFs1FoNlXZ7x+/TMUrtxaLC8gzC82ZTv8q6FBn8nlKch0PQkjF5bX8eq69cZMiZQ3yD+nSxUNPk27ICFFqH6NjVg1zOSbZdr9FSY8vIc5AZMGZcHRPYfso1fZHsUfBz6XxCr/xA/eGOtjewy5ZnkKtWaHfars5B85KM22hqmo70OSSMCaxr2MXGdHKR29RhKN7hoofMX90JhvdrRFGbO+GVAk78zMZieaQSzMJ4xadQNp1AjufAVKGkGexY/Y1bF+tU3YWST8I4E+odMg2iTIfkIOpnmvaw4IwCx/Zug/54MlDXHqKw5TeyUNKozJeSdKkvTwvQfaVtEu6PzzCbfL0LaYqsaNuStyZxpH4UOFBvlkfKc0QFXurtUWy7UKXkA8hZ+JWx474f+HWb/Ikz/Xx6FomYjafBosZEQe9YcUJYmTjXZPzXFF3vZL94L6b+5GaZ7VJ0q95i4NCzLgp0SyOzsVgRKqNH857uBOjaqd/J4DeCQvH+jMmNS2jUviHlmhy+0o2/ccBlGavI7aDw17ATSCsmHrjNmsWwOid4GyyzOqNXJbLyNzfHaIkP7amUIy7rfwMlFxpqrq6E2mPWRXJP8jv7x6ziSVOVcqH41RG+N3gWASdN1QBydOh0/kTOlac0OUt219WIHiPk0Erc7v023r1GMDX2PrNxYnLiM7rSJdEqe+qIx6s+4yrupj/mjgfHJyk+oL0OybSDuakNd2+GbdsP26DPbymByxpyBa9gpaX9MCVLilUpDkH/wVeXu8HjK66l250uxv3sWNmuljmVqipcrd70sE9PS4+mam8FkLEKM5v6jmpBPhb0n4dWdx+XRz10RBpVy5fafKjyR8KIOtyalP6gsLQlLJ34BSZwWpTRdK0OYuxFoloJSknqTwNPbSqf1BF7b8KKObfKR9wZea0dVUN0N+ZFjSpNGlmRZnEp+E4anVTv4IDq4tfV+WR5GftJofDohBvH4Si0VYmpupJYXpMGRcRg4C7D9EVlxDoSnGx+TScfIHtHsRG1C/e+uzQ0u5yVIv3Qa3sQKTkwsusgQyOWM2ccmgyPEKHnlDQDSpr14bTgjyzRj5Gq7V6Pl4tUeaNt9DMIbeQzIbh/CaVJ3xratMltB2VnV8Jzcc8ofSG0naxmSp9VCy8m2F95igRgYOKjy6fpJ6n2fabG8QH4uxfNzgJMCSpoVYbhvOCin6jkb5WOQPanSM+fqtLQbh7vlEfnudhd6IZUn9Y9NKh3dSYy/yccFNv3nL0NW038xsrJ62xIVlaBqKrn6w2KfkOKP3wP5Q2fh2P4lOT8MGHwvloCGapubgkHVz4SCEP2/Vs4/dUaZUfNIUrYwq9w6O3RULns81MZsefYnsrIi0XISNFMixb7zEIyfUMkdzcVaprvxAp6GVEl9unx3Uor9+B5p+porJdrBQVHT+k6O1ErjJbbzyZVnMHL69zcY9BBNSvR9ODs5pMzo7bALO9e9GO8j0nFsEFMp9vwOKbf9d6G8XXU0iU4BCrcKec9LubFHoVd7al9ilcf5dvgI4GzgvgM0zsRlL3Gztmq7X35DGZxRKgPu5vqj37Pt5qCdE6Nz9Txg7ccBfCxvf0ga/BzuLrHsBlrWdnKItNpG0365Gwq3Pql8zQ2L9BwbBPeVO6TMfddL5ezjQBMlhzDQtRAKUA56Ub4nD6DHjWnfaH+DjYnKYzjFEnxciRlDkT8soj5rHZa671Ajlcn/mLv8cihcc6Vt50QOp3CDxwLrqJgBSvr6G5kgZyR3cULwDoqjX4AK0mFfVzbXSgXGlDj4YN/1QpiRn9kvIpZkVf2wByYKkyF3ujimxB0XhzxR7I0aiCc0CFCnzbLOru/mIr2bvu49ULLsnBAX31HEnYnmrjLSL1oiUWySZTcQ5TUcF9AQH1azty/C8CaVrkHTNpuxEiJjSuztqYmfoIHR4IKojRKr4GbZvCFOhjxo8hNTIqQT/v7njaDFdFuE1QMA17LtHVphatFuoJYft23zFBAQJIMlSJNmI2oiuXeaEcuT8820tZVn/xom0dUng2Q3PFFwSrRtnY7td+SYpHDtUogMu8rWQcgOdRu7ugTuJvNqMzslrnxyyIhlZ9dwGPJjMdQ0QErbaYDEAXObpxj9N20kOR4OZx8S37vZOBqgslPUZgDcbaMFIRembNvsI+GUZLdqTpu2I4fsZqUWOy89DSofYsdwwKvtJiWnsjaIWrC9DMQpsRSqj+r1z8ZGzqfx/AS1s2vPqKR21GzQ5eo5m8+vDB12F4aiOkNA5fgwUjVesxUnfyMLc4SwguuBTXe6jvNFrPQU3LcgG9tda3naDqekWZ7VVRyI/WwMxi1nzvjCuFW5fg2duF5zW3LLuySa55mbXFwATknLsmTsWvC0B404NuYzzeu/Rfbcz/0wbWYVg80F6P9qdRgOAtmS/ubwwbJ98Ezb7kpOm6NjbY9T0qr+WzFYvB8Gt3YbgxNfs6Wt6z8k/9sfKLNbxCMasLU4wG5ert3kwo9Tsnqgawy0mCxspj1VG1k7+/U3YPiI+rt8Lukswsf3d0EViXalKeFG0EegTGv8GCdRSXjU35dGJqprgqkKPptqjqwVrNaVHizGX6jKtVDM4KrzsZOwbpnGLk2mS65QhNNtBdaVZ0/fAgVcX6eAv7Em294YZc3yrG6p8sqH98BY8WMSpD6rxL9M5lcgO+zG+3rltCDXf3+PNHvTHtiMTKeohH4c6Zaard5JWrM8c/7+gvneqiyZO1+mB7NtQa1p/X/3lYq96MKrknQj4SooplH/j5yErgppcpOp/bIkL6e7JVQ1JRbGza7Up7BZnuGmiO2TgCtKsCWwXVEt6L+zsYm75OnpmyRY6YMpDMid3F2CwmTa+VT97y3x7LCUuf3LMPeNBcCJGzhweFEezrYe2Na0XNdvYRN33byb9uUphzvpI3VfI9rWacGzUdTDdrxHHe2YDag7ul9tJOK8357RQGPY1fWIrbMs+t8esy3ONgT9PZxZgefM6VFaRw59etTO43AwaUzOgpaHxso/NmyMJnNh0f3WvTCHslNnZlak/jeGm2UkHzhudWYN3OwR5YXUt1ixC4lnz9qWkIdPtbUfakw26umRn5mSoHffZOaKiod0GqchyYiHkOTithuBdmt1PXi9lHEj4EfPgZ5fDGSmwFaplNn+boki7Gnnj/sA+zBkZ2lcghM8qeAJqrxbPe/iCayv5vrUh4xZIKKI7s8mbe0J4MtL0vBnLlPw8X6Hy2FIVrSq4+4otp0weu/GDTiCw+mRExiETIbQxzxW28niAhtGQEr8dEGZoaA02/DP2vzg5X8CeVzSpjQ87SZBZegvitN/+OEtUll7l1POfWpXSs69YNkx1GY8nMVd8h6FNzW2iPKuugqO4GmhetKfcUPRWWwL33EmQtshWed9O8lqRa1CkDnCynB79HY4fEDdi/xpnFXKJ1toZWR+Ws/LafmeuZZYmArTgzNjNEh4bYGlZTw9sVsdtSz7id/wg5ElhoWUz772Zw+eHBa1I8izHaHMIkFyos+YYZs86ghOlvFYZ0swcG0cTBCydhDGcO6aRmWhR7R78krmmRJvbGjUZ+BTCfvdQNpON5Kn8Xnrrg3czWV555N7zEm75fugEeRO9tERPA4Jyzt65vCskKZjXOrzpNnywpmReOpm40TXWpv9HKQmzfe8CHpdCcQOftagybI7qVk8g33ez0xJsAJ2H0yjkJPiiTl6u46yvoG04BBJn/6jldoqjrBpYKDnCZwChNTX1KPtbfQ4dpfkD4duAFBgQ3FKsF7Hy7eIX3Q5d+DsEbJtGpchNxtyQjKj0OJxzQl514TLi+Yc2Njo2+ER5N3eDiNYA9cyrU8ZjuXc/tC3b9psgCFTOAmg2wShL3d7/nYoWeo2ZMeyJbiC8h6B5cpwnBLsWqzvTyMeGRg5cBODkelI2mjxsEnZlnWnTt+qlg3Jr11baxMt8uO0l540Bbt8cynEECRKK81HR2m/bNPHhnvkwdL9sG3L++BVBIqmcLuW1bnKQ/j3BgS23KaqGihGLv/Zy5D8bg4e+RAGXKFQK/SsrEDsLC4N4N/X4Rkcw9mwQWugJYE98m/kQuGHsPG+NDzhwGg9YvQC1rsNzwVIBxOZW9OqZLli5NHkscIvjytRVeWqppC2ZrwDiXMOGlB+CBs92egTQlNbGxhAYWeNIM1lUUt+3q1QbcBjt8KhjaqeK/xC/tFkPMl2LidQ/3//ITn9w73wJbKPeFaKITtvnlXo+dL8opxEGxnwMok3WuHfkcvjZdhw8FPw4LXvhdN6H2Lh2Z04o0uz8GIwehWS2gmyBI2XLdLz9X44SBhjb52rpQPlR09OGj1porP8gySUy2YEGAFGgBFgBBgBRqAhBIKdKWmIBH6IEWAEGAFGgBFgBBgBAHZKWAoYAUaAEWAEGAFGIBIIsFMSCTYwEYwAI8AIMAKMACPATgnLACPACDACjAAjwAhEAgF2SiLBBiaCEWAEGAFGgBFgBNgpYRlgBBgBRoARYAQYgUggwE5JJNjARDACjAAjwAgwAowAOyUsA4wAI8AIMAKMACMQCQTYKYkEG5gIRoARYAQYAUaAEWCnhGWAEWAEGAFGgBFgBCKBgAS/9VtL8JvfrI8ENUQEnXv/zjvvgosuis759+fPS5GihzFaXVyZZ6tjdA7fngPwfhSn11d/WMwT0sjIR+HRR5+JlL6xLK3O/KhhFDV62GY3JkOy/FXqbM/DuXNRmjF5DS699APoKK3eCFFPXHKJDG+/LYmqroF6nkGMPhYhjGSkR4oQPQDR41kJMUpHCiNJehtt5aUNyJuwR1DJrkacfh4pnKInS1HT//PIs4uYZ3XVZB4xui5SGF2Kqh+lfhZ9Efn8+Yuj5IzU5SjfZAQYAUaAEWAEGIHORoCdks7mL7eOEWAEGAFGgBFYMwiwU7JmWMWEMgKMACPACDACnY0AOyWdzV9uHSPACDACjAAjsGYQYKdkzbCKCWUEGAFGgBFgBDobgQ5xSgoAEsbtSymAcmczjFvHCDACawCBMbRFZJNyaJs4MQKdikCO+l28UmNta2GHOCVtw4MLYgQQgSJAgjsUFgVGgBFgBEQjcLHoCrk+RiDyCFTRKTkdeSqZQEaAEWAEwkUgvwiwQiTE20YHOyVtg5IL6hgEinMd0xRuCCPACDACgSEQT7S96BaWb6oAkzmc5kYPSYnnoCsGkMa8ObwXZprD9a2kha5kNhyaVjDAZSSDGCEuOkYxpCszgrEvinspPlXnAAaRpriFpkQaYAzXvsMgqTyNeCQBYroM4Wccv49gvmh69DiALYdUvhzaYpFtjb4wYgRIjsZI1yw8I4wGJwFCVjXxAlynxjnEI52wyxLJ9iTKfJiJ+DeIdOgyTjZgMAT5JmGJnM1GJZ8eVfnmtJGlEIQ7SjZbt0ee8RooVynNLo3h3yJSeazWJrY5pgSUY+bpXP6mrgUZeoDeTSPDuvUybNoqw1a8+rrUPFgnwwQ+01SZBg2vKkeEN/XbGa3eHhl2DeDfWH/vJqQJ/+7Gv4lOQDpnlposV6Pp4ovfaY4e/N0S0rRex6hbhgENox6dHsRq5ow/emT5x81jhDQdHtKwQLrWazT14ec6jc4upHFJa3NT+Mvv+KJnhnil1d3dp8rQ1k12es74okcGPzyb2anSoPOoS6dJ4x3J+MPzfnk27wsjkqMuXY5QvokGm1xj3oJPjPCQ6ebY7Lfpjf8O9exqXzjtQhwUWdJ1H3EaQP7pst070TgRTlD8yJJOz8Au1Vau0/RtU69JUw/ec9bV2Hcf+r8QpM0+54tnMtLUt97BN9T/Lt1G4ucefKYxTOzP+eFZsDb7p81jtIR9q6b7u1xw0GWsz6dsN93Pop1ZRHuk2CDt0vt8/7Js8u1d7zpHrPbnlBzdoSrWOiTM2WlMDahCtm7InzDJcgtOCQrxejRO82fsdevM80uTHwF/WOtce/fU4qDT499QNm+UlvZryo9GYP8pO01n5k2DtRmfa94I+HBKkIZNmkHa46CHjJXu9E4478mN0eeHZ3q7jQ4FFbB5LLx+48MpsRilHcdry9Xp7N5Ze68RujvGKTmqdWSo/4cdur80pTkBdK9B2XFi50eWDJuD9Q4gDdYyrZ2fP/luXv+Dtdn+nJKd3apN6kH5dQ6G9H4E8Jl5H3zzw7NgbbYPpwTbbcgK4nDcgsPCLhW79djfOrFzyq/Xdz9OibMsfWAZulPiJMz2HQ2EMjpB58DfCK4FpwTrHTrsYqAxTx8xzQgS8HoYLU5oDgIKVL3nvO81b5R0I+nldBxHw0AjzS5fQu7DKVmFDxN9Kj0DM/4w8mOUdLyj4pTohsfTmbY4b37kumOcklVkaQgdA5Jtt9Gmt46ZcudHlnQZgl4ZTrnQN4H5RFPPHj/y3bz+121nyzbbh1OCeq3MbGFn6+p0oHO5Ce/TTPzO481j5Idn9TBq3Wb7c0qIpqNDKlbr8VOhEfHoJuwQG/+z7XLzMzcuchyAU9JCTAmKlGvCNd0k3TgZzpkhuawLVZinZxcFrb25UGFkJRSAMCEtFSM3wD9wbXYO+UFpcNC9ngyux6PMQbXQzkBq97oayU2iHFEqR4BfjdAbxDOzc2qp2ZxH6SmU6y713lzR4xnOBl3fKiHIUg/qW9KFB1nNIJ2MAt9CsNlzaGcodaFsY7hNbYqhzUJ7tLKMcTCZ2tuic4TbbEsD+/MAu3oA3jyA9htxG0bZeRXv70LZySFOHZb8OyVK8B0pHAq0NUhR2qj4I+EkZBzaadcUX6dmizRM1RLAaD8GKCJGRjAwBSZhAKWeVlypbXMm8gpJURIFuEYplfYB9KNVsgZxElZ6sCmgUbpQU7Wqttwt4FaXpwe1vcsV7dkLFSuKii6MqUHT1iBuwmmvZpCE6JqDASkPg2TsWkDdrAhiWpRsdgnbTSmA3RstoRkZm+1oxTg6I9i9wRPYdxx4E//eBTDuIVstARD+j/1tCV5GgJIIDmID63Cklt2Kjgn+ncigUcDP0Tujd86D4umicRJlmChKeeNelcPrUJq29qt/J/EzjR7CtkfU70L+x479LFVUx2kTQoejEoou1zuMnk3onCTwgTh+IkalcYBHXgiDqujUWabhEKauPsQkWZ+u1e7X//Uav4vynUN8DikGCaAvi/ZJMUiYjwaJdnccitjBM8bIG8kUYZOiZrOr2mDDy2kLQyIjZbOdAKCt3L0Z+40jqozvxv6lQ5MPpwQ1aFBzSMhbK2PnYUtlBC+CTkm1olIZx04v8IROR1ZzSAZmcASXc9RYEOyUYJtpougsOmXIHs/ZpMBxsVRQwo5CcUjWA8xUsPNw8KUwzU5Jqhs7U3RMMmiApp0yJJJZEa8rP6g5JOh0L6CAo/22pdLu6Dkluj0iJ9wh+u1HO4I2m46SoBSZ5dlSxGy2QwqW0R4Oaw4JjTC3oeOdKbovDbZfgISW6GP5ZhaAsKE07nRIKBOZS31NKKnifW7DMjKSEi2lBJ0qiJEyyEUjSecCOFMZhUloQiud1ipcRgMVhTSLGFHqGat1SCi/iHJ0oadUUkVAuLysMeBnNYO0Fe2R0yGhppRDM0hojyruYC5XtXy0R4GbpAja7LTGKAMHd5iE5UbOZltbXkYHZJs62z2Bf+/HWWU4gU4U2s4OTD6cEh0FXLZxU6b8vhBhQsej4NaZoVLiP2W6IOtmtdpMMgVnKQkBcsNo33SbK1ytOCQig6NuStMedeuH4sSyICSMw4DIDaAi0qktXazWtE6+3685tCeRZ25iTfP+2bh6GJ/ex3UyHl5tQxiU5DbgWM7jLInXDwXkn0DDo9NnrU53yvv6BRChVxEhm53R2n264CHbSLPysrcYhgOgPQg6Rc5mWxpMByeSXz0whVgkccYEMRvAGeaTOBsvApugsXeU78MpSakBN/RykGmHsMyNIkhoHbUNAYLbolaX3107WzKGdNFEyfpBXJsXQFUqo1VyDDFatlSI1mlfFh0kVDTRafdutcYjiMW0swer4Amqk+r9DGIUF0BcBuWI0rG83QmiYDzamRDDWaawUiqh1lxy61CQh/hPSEqOoPGhdTd00AbHHPWSLKGxOoJxFHQ6sEayELqiVklKkxVa8rMmOr04g/LeE6ZBwlmcsZKdLorv2K3FSw0iDwNPqGsKRBGy2bFhgJ00UHKTbcwuouwrziQKNp1AHXSKos2mNhdRfmmZe/0AAC1TKgkNdD6vrHzDg2grC8tafqd8+DnRVT9DgvaZ9+K5FsYJk7RvegnPCtHOBejeKsMUHhy06LK/2XtPeAvnlCAtyvkAWL9+yqxxgqpGm3e93nvh/ex5H8L69BMmFVo24cFuhAvSt3AKTzKkfeZ49e3EU0Ldzlapi5m/cwpmkA6FJrzW96qn8llPmBR6outRy4m3iAmdEKjTQgfxnJrQaEUcdz6MB18tePPHjad+eKaXc2a/iROdk9DVpV2aXPs5E0SWfRyehjKwhLKhnEmA1zqkQzkZGOXcOPUSsTt+pjls9HZ2yjklhqwgRl2aXNNJxYQZnXOjn/NAZ2JMTCFei83h5UeW9HNKdqAs08nO+unA1lNm/R841bz+B2uzfZxTQvYNdbpX0ymy2X0o17bTijFP5Imuwdrs5s8pMQ5OQxvkdh6JcX4J4ubnALVmD0+bf9h+mqv1FPd1aIesJ71u3dlsvy9DSye6ymgEH0YglE6WDCZ+knNyfElV9kU06rrRXNfnfniQW0ei5rXmlBBtUzssx8s7aPOu19tQ+TFK8iJ2pth2/dA26tz6kK5TmrNxHI2VcW/Iu253eps3Sno5i0fRUPdaeKcZ8gnMd6+rkXx/h6ctHkZMtM5DcZTw7x1TWn3Ix12In+5EuR6Kp2HpRrcvnlnKW0A6ervM+knGyTnZhDz0dyigP6dEaRvK0gTql+GI6Fg93LziW7HqFKeE2kQGsxd1TJcXck4mjmuyhPgN6LxEPjZ7iqofWdKdEjqwTdc5Q9+tcl5Hht3kWs3zof+oT8HZbJ9OCbUd6VLstUXXdFu5gPe8Mah/zw/PgrXZTTol2JcOaPJc7/A441TcPfXxcMOxWafE+loQXc88P3uat5OaUyIp7745d87HMg6qfzDpNbj00g/Ab34TTOl+SiXmvf02LnBGJj2DGH0sQhjJSI8UIXpAOa0wWjwrIUbpSGEkSW+jrbo0MlKNhKCSXY04/TxSOEVPlqKm/+eRZxcxz+pq0jxidF2kMLoUVT9K/Sz6IvL58xdHyRmpy1G+yQgwAowAI8AIMAKdjQA7JZ3NX24dI8AIMAKMACOwZhBgp2TNsIoJZQQYAUaAEWAEOhsBdko6m7/cOkaAEWAEGAFGYM0gwE7JmmEVE8oIMAKMACPACHQ2AuyUdDZ/uXWMACPACDACjMCaQYCdkjXDKiaUEWAEGAFGgBHobATYKels/nLrGAFGgBFgBBiBNYMAOyVrhlVMKCPACDACjAAj0NkIXKwc4wswF5Vm4omOy0jS+5EefJtdRJIsfyJK9CBGpxCjj0aIJjriuD9C9ODhx5Hj2RvIs95IYQRAMhS1dEazSaz/HpyJoP6fR57920jJdsT0H7H5v4hROmIYbYoUPQAfJ5Gno9PfwOtf0pcIpYuRlnNMT10EGKO68EDU8CFqo0YT0fN+dJZerw+luLuSJH0Ia3sFL9b/+rBHUZaYZ8yz+gjUv0syvUtSJ0rqP8l3GQFGgBFgBBgBRoARCBoBjikJGmEunxFgBBgBRoARYAQaQoCdkoZg4ocYAUaAEWAEGAFGIGgE2CkJGmEunxFgBBgBRoARYAQaQoCdkoZg4ocYAUaAEWAEGAFGIGgE2CkJGmEunxFgBBgBRoARYAQaQoCdkoZg4ocYAUaAEWAEGAFGIGgEWnNK8lL/V1NSKRGTZDxfgK4VvIp4pVaCpny18h+V8nGVpkJhtWcDvF99QBr83G9LlXgtRulqgPV6FX3iDmm0304P8a2EV64cOtOIain+7ZukZU2exPLuB9J4SpUZXZ5dP3NhCNRfStltqGsWOSKM9k1XvDh9IeZLiW99USpcc6Vih3TeVfDvwfBlW0pOZgyaUqFxx91mh6f/z0up+/ulOQfPFNnGKxEaTpaK0YYXtL5EFq37hZwhM662SJPz8bJooL4tpf/0E1Ixae9cZRnnAAAOiElEQVTXCkhPvGVS6JwSP9frD0C+G8/NRALoov61GovB8jozL7fks2w/9Fh/89pfw2SPSUdhJiQ6Fu+HwnoHRvE4UNev4za2IIw2iH8nCxVL3W48K8ws+ZOHVnmm/96BmVjefR/GNZkmHin4uF07DovFyE3X4jFDjsq7FsTS0y5et7WcZyE71G3olcG/9euMvOnwZBuSj3wUli26l2pr2xu1ISjfFrtI9DhttliMvgWjfetredZl8ozsZDhY6Zg+B7kBk0Z5YEasrk0N2PtYN3uEeaOnGpWBdjxn55tiIy39GslVvBX59uWQYLv6h0xGpc9YG3oQhjeb92KtENfUb++F+GO3wuDwH0BVc4zKXWrnL7Zj07F4EhXOdD5sGC0/bjMOyaba6Veo0InUcUGhSdjq3A/9O3oM4c8KocetHaYBqITCO3QitY5jTKiSu2Gh55VgcMA00hY5gtiztwENkMhwj4tzbsUa5UZl8ambjU5/fP6MlUabQzBss1X1cG/DvRfvhfTf3AzTPSr/yj2mjoXQ0dps9uCitX1HUMZMmy1I/yE50WvYnJEFO89iJ+6COc1elSZOhSVzED94oyJXle4ulVaxTgmkdmkys1WwM+StdyZNiItNjn5xrzEIL8zY+Nkc/3w5JW/dq7wrh4yhq4f2z3fDbL373g1ujni9nHnTOBNNNErK/swcFYTilBS/YMxKjLjNGFloFmIon/qiYbQzrvibHXL+aBsMsmsddcuF+N/+O4V3c5/5huG0ieWdiUGuefr9ye5q9VjkaLhWjiD7eXXGpDC1GEz9q9EXifunYXiTao/cOzC8v7ne/bpy6QdXHF2bAxKySWQPYzPmqFe4U2KxyfuOu7XXlP1J1/tuv2klrwAjfaqzNrfftQOzdX72QVQr9Tbx20XsZDXHKKM7ByE5JZGZDbXIkYucQPL+jYoNL+2a96M36m98xZR8rwRoA5Q0ndT+sH5c8XXIo1JSGiwICJy46BLFAXgCr0+ix02zM7MfthIk/G8p/vxrEMOpY0oFt0W29IeVUS6lVEX7I8iPGx+TaUqNXitQdK1nI5Rx6SK0VN0N+f/4JBBiue9/IBwyfv0WuLEqHGKUWqXM1NNAbDm987icryVOnn1clffcYCJEMsOu+huQ097elx9MuhBzlZwfVg1S750fFBKnsIIvFCOS9uK1AWdnaPaBjHVo6cQvIInLIpSmM25UoP73qPlJASYbYEDeV1xR7FH/cMyNILmcTrnlC8p7QRocGYeBswDbH5GVAV0YKb4SVs2urZVif/csoH+vpLFaOZIrd72s9L/p8bRrAQ1l+nBKpFSppJRNhtJLfkspVcL7iu5dYEPENfrQh7+pKP0gXnMpVwFvtKR2PScv/8mP5MSyqnSuGP1gHrJabbNh6p7e4rkpGHxV/VKoFbZ24eJRjsUA4GxAaGr4yinQu3ZXnnlQH1z209A/e1opfq5fOFOCa1a7S/7Z66CbwKKXb5ZaDye1egUgKc/+BDtbtEdjeFWjYJJuOCinqqo9mnPDv3wMshpAcwIAciPBnveSNLzvkJJ1EmOmBOujFH/8HsgfOgvH9i/J+T9endqgnkhUVP2vppJBVdFUudlZ1fs/uedUcE62D6cEUmW191qO1Q7d9BZWUpp1WFlpqtEXxsO4y+PL/12ZFXh157w8F2ajX7lDytx3vVTOPq6MyA9hMGBBrBGV4vmdMIUG4NAUGgBvkRKKUkzZxXGZbRcH7VDoF2odfwJpraOobAEpMXWDNLvBpIl2mFC0u1c/LBSwMCv7P79SZJeSp0N79QeVoGVKYsVbqzTSH89LubFHoVejcV+oArUbd9/9F2my/wbYr81+5cYFj9p+uRsKtz6poJEbjoZBWt7+kLqLM2buKtN3KImT56chpc5HQPnupBT78T3StGXXVNt23vpxSmr0y7JtqTxWptvyCkbjKunQNkmwSNWQF62M/ykN5r4Au7TOJjupj/GEUinlcppw/+v/Csf/rAiA05TbcOkrlxOshGQAth+j6mF4UHDdTsj/8Rwktbyjt/0tDCysKJ3caZRloo+M9tENkpSf9ez6nCW2+P1SowON7UrB4uf/F/RXV2C2uxuObVSxokWJRXRMWMesUOMWTm2rJG2jVLC5/ArDYUkrJoqTisBLUnrsCzBz6E3l6xacqQxlGFkaksoKz/4clm6ZgJ3HTivL8Rtwpkksu3CG5pY/V8ITKIZLlKa7S+MJ0JfSBuArMDXzOsTRENHcyWkMDcCNnbADr6ow/T9rLG8v33ETVD+xB3ILy1C8/HI4dM2VsIKjbNzbAQuX4fESrQDXFqfEHVHOdSLw//5KGs3cgrMCpgEQq3AmQSvoXivCrS4zAy22jW+8TPBMQJQMAALwT79WZq8okUG8DA0iBdgllpbk2K++CV/CXWWUhj59pTQs2HLv3HsS9uKuElqvzVUqcv/LSBNGux9SSYLZ0ZJKOP/PCDSMwLel7PBnYB5li9LduIPLNf6t4fJaePCSK5SZrNO41Z0GAJRyeE1ihytuJgDPSMrfrszQ0KztdMhjJIB/gITWuVOP8UncMUVxgYpNWl6BDd+7WVmSJBMgWv+H/uppmMPgerJH/W+9Jede+kc5fvpx2KtGbcDMla3wDQttcgeOEVluRARbosq1PIjt36RtoZpqtvw2PR/y7hsnrj/DHUnaNlfqz+zbqJvmQZsw0urFs0EGt3Yb2/MEnS+DWwL7lDoLaADsMhgx3hm8xPNvcJ2AaC5OiNjtYu6IcN9VIqOebTb45r6rKmTZcupBEN9rdrWYuBGvlJ0ulh2DFHvWpM1rz/M1dIZEB7WfznLqNbea27cIh0iXwpuDkPjWFihib0v8E7bz5OVRwDljZfeI45wNcyeQ2N03q8kdxPV+FmmmGKZg5dq0yytDHmc1WXcL+t1+72empJxSV3CTVfJtMeUKShQ1XSlt/S9Zrii3zsYT6jMX7v9S/KkBqfSRPbAZpyYoGofOJSkJdP9XhT5xlzw9fQi24XkYlCZ3Cxh1L9wJ03eeABoBhL5ssypA+gN/CHNp9e94tZX5yUYrjAOd10Kpkky6/UheSXcZAZwXrKb9zr9S9IqSisFdMm3p1m2SMhv5v183luY0q+WG54WR9/f3SLMf+SPY+cJZRf+uw85jOlLCc7NcvfW7cmbuNkW2e/ZuFDAzeVga3T6pLD8Mhr5s07AYysvpbkP/g5/Y+QiUNTmpJJLuRPalQe89UhX3R1bN9eGUyOWMapnXHfikR5DdLyFTVM1E8cLeNSDFv/tpKH3qf0Avzkke2X9KJockmkaxF0pahHd3xa80rSpu+gNS6sBhxQDQ1OOSZf1fPUr5s0bMzcAWNfZFi1VquILOePDfI0/UlsRxupaTBwK/12MYQo9XN0ixn75iBMPSaPiCTc/fKRU/rg6QqMOP3ADJyhiRxyaUpmHkhFo5LT04jnSHBW2JCw5ticCrAsKS3qugjIMgSoFuVfbhlADceA0c0XAZVYYhjlR+AEa1yOlCNkpTAk5CA/5eGoLif5hVjOGBw0tydjgZcIWexUuZ2zeoO0nqvLshWa2oBQhg2fK/OK/EbbhemavhpBbcQXEv9MxsJuhxAMa33HSZ8s4dbwfoLyA3q0JUzmjegifk7bhxFUzTqV+YNm2/zO2dElIcnX9tGdc496YdNa+tMm6DggoTjEy6GaTDmK8apBO47HbBunf0DpcbcDYAp0dOTCzItKwlYr7PVZaqd+H7ZNT3pni+t6X8S2N2azlom3TJe5QD7lzt0VVXwRE8lVdP+jOBY/fDW6Sy9l65nLvQSsm5F0Tqv1zcdqMyK9n14PVSxo2xP3oO9PyibxPpbx0KMjvNGISM9aRJyxHqy0NHA17jqreGFnJcwj/dB9PammhtzEQ9ugO6ZzmGm5SPApTM9cfnIDVpvpujpSOC/cmTQ05C4Z0tPmPyqCNm5B8etL2nQ1z8hhnHQt2thW8QO4Zr4JqMFcM7ijtEHbfI8FHzBOXJ49YYpRchrZ/GifgFv+5eR39DjSk5CGPovQqN0ahrC+yv4ei3HXuPGL74F7b3lylxQeFdIcWUHDRi2MgBStljNCBheZfZHJ6nIgafF43Tk4km20m7OBmR12LuWur7/TfE/nInWpKwvpTHCDATIkhfh31Uv/WyvCCInEzrvbngDTikLU4bMc9Gm+P7vsNCFM52bDPxx6AJBwH0Xc9r6WVKbeF3KE4JKjW+e2er9o4LxMOQG4ssEUajot8z8/ztUHLwqGp5aRnJV/g8EyLD9QyvTb4N3llwE/h+IEh+7dpanbe8HNBpD+jwR/+2eNXf2hxupz100iLAPqptdbx809Q382WTpG8CX1rqxYOQnBLkq5vuk+22yFJFtP6/gQNubdOG0Y9YXhDact/fmiLgi9y+guu5FgNJglXAy+ZBBatwKEj2aHu9g/X6FBDNXfPuCy9aKF/g+10gcfBTMHnte21CTTSQYI86ZwcC55uXMQ3LKSF6cNbo/uuh8Dv2N15Tx09y7RiteBmx9ucX/zOMfhz5ZulkiSZyxu2zXl6YXhD5kMCXchbwDBeyQ7rOlfDvmpF4sLJdMwCop/90L+B3LTVFjwD7aOrH6/dCbksKigk7z4h/c2Hqm10+wnNKiI5n9sLIlvdh0Lu5W0q32SPzInYButgO2rFJNFmco7b1/RShjrznxAgwAowAI8AIMAKMQLgI+Ap0DZdkrp0RYAQYAUaAEWAEOhEBdko6kavcJkaAEWAEGAFGYA0iwE7JGmQak8wIMAKMACPACHQiAuyUdCJXuU2MACPACDACjMAaRICdkjXINCaZEWAEGAFGgBHoRATYKelErnKbGAFGgBFgBBiBNYgAOyVrkGlMMiPACDACjAAj0IkIsFPSiVzlNjECjAAjwAgwAmsQAXZK1iDTmGRGgBFgBBgBRqATEWCnpBO5ym1iBBgBRoARYATWIAL/Hy254WeV0kQrAAAAAElFTkSuQmCC"
        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <!-- https://github.com/arronhunt/highlightjs-copy -->
    <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" />
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script defer>hljs.addPlugin(new CopyButtonPlugin());</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padrão é 1.21, vc pode remover essa configuração se quiser deixar o padrão */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* tags pre dentro de tabelas são alinhadas à esquerda, sem margem interna */
            margin: 0;
            text-align: left !important;
        }

        td:has(pre) {
            /* tags pre dentro de tabela são alinhadas no topo */
            vertical-align: top;
        }

        code:not(pre code) {
            /* tags code não filhas de pre */
            color: darkred;
            background-color: #f3f3f3;
        }

        table.align-left th,
        table.align-left td {
            /* alinha à esquerda as células da tabela */
            text-align: left !important;
        }

        .bordered-line td {
            /* tags tr com borda em todas as suas células */
            border: 1px solid black;
        }

        /* inicia a lista de exercícios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* põe um numerador num item da lista de exercícios, desde que não seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* põe uma barra vertical ao lado do item da lista de exercícios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }

        .info {
            /* balão de informação */
            border-left: 6px solid blue;
            padding-left: 1%;
        }
    </style>
</head>

<div id="8-strings-and-serialization">
    <h1>8 Strings e serialização</h1>
    <div id="strings">
        <h2>8.1 Strings</h2>
        <div id="string-manipulation">
            <h3>8.1.1 Manipulação de strings</h3>

            <p>Strings são colocadas entre aspas duplas ou simples. Se colocadas entre 3 aspas (duplas ou simples), podem vir em várias linhas. Exemplos:</p>
            <pre><code>a = 'hello'
b = "world"
c = '''a multiple
line string'''
d = """More
multiple"""

print(a, b, c, d, sep='\n\n')</code></pre>
            <p>As classes <code>str</code>, <code>list</code>, <code>tuple</code> e <code>range</code> são conhecidas como <b>sequências</b>, que são classes iteráveis que compartilham das operações de indexação (com os colchetes).</p>
            <p>Considere as seguintes variáveis:</p>
            <pre><code>string1 = 'abacate'
string2 = 'abacaxi'</code></pre>
            <p>Strings são como listas, onde cada caractere é como se fosse um elemento da lista, acessado por seu respectivo índice. No Python podemos usar índices negativos para acessar elementos de trás para frente, como veremos.</p>
            <p><img id="string-indexes" alt="índices de string"></p>

            <p>Eis as principais operações suportadas por strings:</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Operação</th>
                        <th>Exemplo</th>
                        <th>Descrição</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td rowspan="2"><strong>Concatenação</strong></td>
                        <td>
                            <pre><code>concatenated_string = string1 + string2 # abacateabacaxi</code></pre>
                        </td>
                        <td>Junta duas ou mais strings.</td>

                    </tr>
                    <tr>
                        <td>
                            <pre><code>concatenated_string = "abacate" "abacaxi" # abacateabacaxi</code></pre>
                        </td>
                        <td>Se forem strings literais, nem precisa do operador <code>+</code>.</td>
                    </tr>
                    <tr>
                        <td><strong>Repetição</strong></td>
                        <td>
                            <pre><code>repeated_string = string1 * 3 # abacateabacateabacate</code></pre>
                        </td>
                        <td>Repete uma string determinadas vezes.</td>

                    </tr>
                    <tr>
                        <td><strong>Indexação</strong></td>
                        <td>
                            <pre><code>x = string1[4]  # a
y = string1[-4]  # c</code></pre>
                        </td>
                        <td>Acessa caracteres individuais da string. Se informar um índice negativo, acessa de trás para frente, sendo que o último caractere começa do índice -1.</td>
                    </tr>
                    <tr>
                        <td rowspan="7"><strong>Fatiamento</strong></td>
                        <td>
                            <pre><code>i, j, k = 1, 6, 2
sliced = string1[i:j:k]  # bct</code></pre>
                        </td>
                        <td>Extrai uma substring, começando do índice <code>i</code>, indo até o índice <code>j-1</code>, pulando de <code>k</code> em <code>k</code> índices.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced2 = string1[1:4]  # bac</code></pre>
                        </td>
                        <td>Se omitido o pulo, também denominado passo, o padrão é de 1 em 1.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced3 = string1[:2]  # ab</code></pre>
                        </td>
                        <td>Se omitido o primeiro índice, o padrão é começar do 0.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced4 = string1[1::3]  # ba</code></pre>
                        </td>
                        <td>Se omitido o segundo índice, o padrão é terminar no último índice.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced5 = string1[4:1]  # </code></pre>
                        </td>
                        <td>Se o primeiro índice estiver DEPOIS do segundo índice, retorna uma string vazia.</td>
                    </tr>

                    <tr>
                        <td>
                            <pre><code>sliced6 = string1[-6:-2]  # baca
sliced7 = string1[2:-2]  # aca</code></pre>
                        </td>
                        <td>Os índices também podem ser negativos.</td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>sliced8 = string1[::-1]  # etacaba
sliced9 = string1[-2:1:-3]  # ta</code></pre>
                        </td>
                        <td>Se o pulo for negativo, os caracteres são extraídos de trás para frente. No caso, se o primeiro índice estiver ANTES do segundo índice, retorna uma string vazia.</td>
                    </tr>
                    <tr>
                        <td><strong>Continência</strong></td>
                        <td>
                            <pre><code>result = 'aca' in string1  # True
result2 = 'caxi' in string1  # False</code></pre>
                        </td>
                        <td>Verifica se uma string está contida em outra.</td>

                    </tr>
                    <tr>
                        <td><strong>Igualdade</strong></td>
                        <td>
                            <pre><code>result3 = string1 != string2  # True
result4 = string1 == 'abacate'  # True</code></pre>
                        </td>
                        <td>Verifica se uma string é igual ou diferente a outra string.</td>

                    </tr>
                    <tr>
                        <td><strong>Comparação</strong></td>
                        <td>
                            <pre><code>result5 = string1 &lt; string2  # True
result6 = 'aba' > string2  # False
result7 = 'asa' &lt;= string1  # False
result8 = string1[:5] >= string2[:5]  # True</code></pre>
                        </td>
                        <td>Compara lexicograficamente duas strings.</td>

                    </tr>
                </tbody>
            </table>
            <p>Vejamos alguns dos <a href="https://docs.python.org/3/library/stdtypes.html#str">métodos de strings</a>. Vamos começar pelos métodos que retornam booleano.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Descrição</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.startswith(prefix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string começa com <code>prefix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.startswith('foo')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.endswith(suffix[, start[, end]])</code></pre>
                        </td>
                        <td>Verifica se a string termina com <code>suffix</code>.</td>
                        <td>
                            <pre><code>'foo bar'.endswith('ar')  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalnum()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres alfanuméricos (letras ou números).</td>
                        <td>
                            <pre><code>'abc123'.isalnum()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isalpha()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres alfabéticos (letras).</td>
                        <td>
                            <pre><code>'abc123'.isalpha()  # False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isnumeric()</code></pre>
                        </td>
                        <td>Verifica se a string contém apenas caracteres numéricos. Observe que, no sistema Unicode, muitos caracteres são considerados numéricos, como os algarismos romanos <code>'Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ'</code> (Não confunda o caractere <code>X</code>, de código <code>\u0058</code>, com o <code>Ⅹ</code>, de código <code>\u2169</code>).
                            <p>Por algum motivo, os caracteres <code>.</code> (ponto-final) e <code>-</code> (negativo) não são considerados numéricos. Portanto, para saber se uma string é um <i>float</i> ou número negativo, podemos usar regex, como veremos mais para frente, ou passá-la à função <code>float</code>, que retorna o número ou lança uma exceção caso não seja um número válido.</p>
                            <p>Além do método <code>isnumeric</code>, o Python também tem métodos similares <code>isdigit</code> e <code>isdecimal</code>. Você encontra <a href="https://stackoverflow.com/a/54912545/4072641">mais informações aqui</a>.</p>
                        </td>
                        <td>
                            <pre><code>'0⓵𝟚⑶⒋⅚Ⅶⅷ٩'.isnumeric()  # True
'3.14'.isnumeric()  # False
'-5'.isnumeric()  # False

try:
    if float('-1.61'): True  # True
except:
    False</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.islower()</code></pre>
                        </td>
                        <td>Verifica se as letras estão em minúsculo.</td>
                        <td>
                            <pre><code>'m1núscul0'.islower()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isupper()</code></pre>
                        </td>
                        <td>Verifica se as letras estão em maiúsculo.</td>
                        <td>
                            <pre><code>'M41Ú5CUL0'.isupper()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.isspace()</code></pre>
                        </td>
                        <td>Verifica se contém apenas caracteres whitespaces (espaços, quebras de linha, tabulações...).</td>
                        <td>
                            <pre><code>' \t\n\r\v'.isspace()  # True</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.istitle()</code></pre>
                        </td>
                        <td>Verifica se o início de cada palavra apenas é maiúsculo.</td>
                        <td>
                            <pre><code>'Um Conto De Fadas'.istitle()  # True</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Agora, métodos que realizam alguma transformação na string. Observe que como uma string é imutável, as transformações na verdade são a criação de uma nova string.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Descrição</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.center(width[, fillchar])</code></pre>
                        </td>
                        <td>Centraliza a string entre caracteres <code>fillchar</code>, ocupando <code>width</code> caracteres. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.center(10)  # '    oi    '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.ljust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string à esquerda, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.ljust(10)  # 'oi        '</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rjust(width[, fillchar])</code></pre>
                        </td>
                        <td>Justifica a string à direita, ocupando <code>width</code> caracteres e preenchendo o restante com <code>fillchar</code>. Se não informar <code>fillchar</code>, o padrão é espaço.</td>
                        <td>
                            <pre><code>'oi'.rjust(10)  # '        oi'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.replace(old, new[, count])</code></pre>
                        </td>
                        <td>Substitui todas as ocorrências de <code>old</code> por <code>new</code>, até <code>count</code> vezes. Se não informar <code>count</code>, substitui todas as ocorrências.</td>
                        <td>
                            <pre><code>s = 'fia, fio a fio, fino fio, frio a frio'
s.replace('fi', 'ti')
# 'tia, tio a tio, tino tio, frio a frio'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.strip([chars])</code></pre>
                        </td>
                        <td>Remove qualquer caractere inicial e final contido em <code>chars</code>. Se não informado, remove whitespaces.</td>
                        <td>
                            <pre><code>'   spacious   '.strip()  # 'spacious'
'www.example.com'.strip('cmowz.')  # 'example'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.capitalize()</code></pre>
                        </td>
                        <td>Deixa apenas a primeira letra maiúscula.</td>
                        <td>
                            <pre><code>'foO BaR'.capitalize()  # Foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.lower()</code></pre>
                        </td>
                        <td>Converte todas as letras para minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.lower()  # foo bar</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.upper()</code></pre>
                        </td>
                        <td>Converte todas as letras para minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.upper()  # FOO BAR</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.swapcase()</code></pre>
                        </td>
                        <td>Alterna as letras entre maiúsculo e minúsculo.</td>
                        <td>
                            <pre><code>'foO BaR'.swapcase()  # FOo bAr</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.title()</code></pre>
                        </td>
                        <td>Deixa maiúscula apenas a primeira letra de cada palavra.</td>
                        <td>
                            <pre><code>'foO BaR'.title()  # Foo Bar</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Também temos métodos que realizam consultas em strings e retornam índices.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Descrição</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.count(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Conta quantas vezes <code>sub</code> ocorre na string, começando de <code>start</code>, indo até <code>end</code>
                        <td>
                            <pre><code>'fomos herois'.count('o')  # 3</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.find(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao operador <code>in</code>, mas retorna o índice onde encontrou a primeira ocorrência, ou <code>-1</code> caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.find('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.index(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>find</code>, mas lança uma exceção caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.index('ba')  # 4</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rfind(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>find</code>, mas retorna o índice onde encontrou a última ocorrência (r de <i>reverse</i>).</td>
                        <td>
                            <pre><code>'foo bar baz'.rfind('ba')  # 8</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rindex(sub[, start[, end]])</code></pre>
                        </td>
                        <td>Similar ao método <code>rfind</code>, mas lança uma exceção caso não ocorra.</td>
                        <td>
                            <pre><code>'foo bar baz'.rindex('ba')  # 8</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Por fim, temos métodos que trabalham com listas.</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <th>Método</th>
                        <th>Descrição</th>
                        <th>Exemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>str.join(iterable)</code></pre>
                        </td>
                        <td>Retorna uma string que é a concatenação das strings em <code>iterable</code>, usando a string fornecida como separador.</td>
                        <td>
                            <pre><code>', '.join(['foo', 'bar', 'baz', 'qux'])
# 'foo, bar, baz, qux'

':'.join('hello')
# 'h:e:l:l:o'</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.split(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Divide a string em uma lista de substrings, usando <code>sep</code> como delimitador. Ocorrerão no máximo <code>maxsplit</code> divisões, se informado.</td>
                        <td>
                            <pre><code>'foo bar\nbaz\tqux'.split()
# ['foo', 'bar', 'baz', 'qux']

'1,2,3'.split(',')  # ['1', '2', '3']
'1,2,3'.split(',', maxsplit=1)  # ['1', '2,3']
'1,2,,3,'.split(',')  # ['1', '2', '', '3', '']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.rsplit(sep=None, maxsplit=-1)</code></pre>
                        </td>
                        <td>Similar ao <code>split</code>, mas as divisões começam da direita.</td>
                        <td>
                            <pre><code>'1,2,3'.rsplit(',', maxsplit=1)  # ['1,2', '3']</code></pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>str.splitlines(keepends=False)</code></pre>
                        </td>
                        <td>Retorna uma lista com as linhas da string. As quebras de linha não são incluídas na lista resultante, a menos que <code>keepends</code> seja fornecido e verdadeiro.</td>
                        <td>
                            <pre><code>'ab c\n\nde fg\rkl\r\n'.splitlines()
# ['ab c', '', 'de fg', 'kl']

'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
# ['ab c\n', '\n', 'de fg\r', 'kl\r\n']</code></pre>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="string-formatting">
            <h3>8.1.2 Formatação de strings</h3>
            <p>Strings formatadas, conhecidas como <i>f-strings</i>, permitem que código entre chaves seja interpretado dentro delas.</p>
            <pre><code>a, b = 1, 2
print(f"A soma de {a} e {b} é {a+b}.")</code></pre>

            <div id="f-strings-can-contain-python-code">
                <h4>Códigos em strings formatadas</h4>
                <p>Praticamente qualquer código Python que retorna uma string (ou um valor que pode ser convertido em uma string com a função <code>str</code>) pode ser executado dentro de uma f-string.</p>
                <pre><code>l = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]

print(f"alguns ímpares de fibonacci: {[a for a in l if a%2]}")
print(f"{l[4]} é {'ímpar' if l[4]%2 else 'par'}")
print(f"o maior número é {max(l)}")</code></pre>
            </div>
            <div id="making-it-look-right">
                <h4>Formatando</h4>
                <p>Você pode saber mais sobre <a href="../alg/07 Caracteres.html#formatando-texto">formatação de strings aqui</a>.</p>
            </div>
            <div id="custom-formatters">
                <h4>Formatação personalizada</h4>
                Embora esses formatadores padrão se apliquem à maioria dos objetos incorporados, também é possível que outros objetos definam especificadores personalizados. Por exemplo, podemos usar especificadores de formato para objetos <code>datetime</code>:

                <pre><code>import datetime
print(f"{datetime.datetime.now():%d/%m/%Y %H:%M}")  # 24/04/2024 21:21</code></pre>

                <p>É até possível escrever formatadores personalizados para objetos que nós mesmos criamos, mas isso está além do escopo deste livro. Pesquise como sobrescrever o método mágico <code>__format__</code> se precisar fazer isso em seu código.</p>

                <p>A sintaxe de formatação do Python é bastante flexível, mas é uma minilinguagem difícil de lembrar. O autor do livro usa todos os dias e ocasionalmente ainda precisa procurar conceitos esquecidos na documentação. Também não é poderosa o suficiente para casos mais sérios, como a geração de páginas da web. Existem várias bibliotecas de modelagem (templating) de terceiros que você pode consultar se precisar fazer mais do que a formatação básica de algumas strings.</p>
            </div>
            <div id="the-format-method">
                <h4>O método <code>format</code></h4>
                <p>Antes do Python 3.6, que lançou f-strings, você precisava usar o método <code>str.format</code>, que possui basicamente o mesmo uso:</p>
                <pre><code>>>> template = "abc {number:*^10d}"
>>> template.format(number=32)
'abc ****32****'
>>> template.format(number=84)
'abc ****84****'</code></pre>
                <p>Uma vantagem é que você pode definir um template em uma variável e reutilizá-lo em outras partes simplesmente invocando o método <code>str.format</code>. A desvantagem é que você só consegue passar valores ao <code>format</code>, mas não pode executar códigos como invocações de funções.</p>
            </div>
        </div>
        <div id="strings-are-unicode">
            <h3>8.1.3 Strings são Unicode</h3>
            <p>Bytes são compostos por 8 bits, geralmente descritos como inteiros entre 0 e 255, ou como hexadecimais entre 0 e FF.</p>
            <p>Qualquer tipo de dados é armazenado como bytes, desde caracteres de strings até pixels de imagens.</p>
            <p>Para interpretar bytes como strings, precisamos de um sistema de codificação, que associa cada caractere do sistema de codificação a um ou mais bytes correspondentes. Por exemplo, a codificação mais consagrada, da qual muitas outras são baseadas, é a ASCII. Ela é capaz de representar apenas 128 caracteres, dos quais apenas 95 são caracteres imprimíveis, o que a limita bastante. Softwares modernos utilizam Unicode, que consegue representar milhões de caracteres, mas os primeiros 128 deles são iguais à ASCII.</p>
            <p>Mas não existem apenas as codificações ASCII e Unicode. Se você tentar abrir um arquivo de texto codificado em outra codificação, pode ser que os caracteres sejam interpretados erroneamente.</p>
            <p>Em algumas situações vamos receber/enviar dados diretamente na forma de bytes, mesmo que representem texto. Nessas situações, precisamos saber converter entre bytes e caracteres.</p>
            <div id="converting-bytes-to-text">
                <h4>Convertendo bytes para texto</h4>
                <p>O Python possui o tipo de dados <code>bytes</code> para representar uma sequência de bytes. Você instancia um objeto <code>bytes</code> como se fosse uma string, mas precedida por um <code>b</code> antes das aspas. Cada byte pode ser representado com o caractere de escape <code>\x</code> seguido por dois caracteres relativos ao seu número hexadecimal.</p>
                <pre><code>>>> characters = b'\x63\x6c\x69\x63\x68\xe9'</code></pre>
                <p>Se imprimirmos essa variável, o Python interpretará, por padrão, essa sequência de bytes como um texto ASCII:</p>
                <pre><code>>>> characters
b'clich\xe9'</code></pre>
                <p>Como ASCII vai até o número 7F (127), não há um caractere correspondente para o número E9 (233). Mas podemos interpretar essa sequência de bytes usando outra codificação. Como já sei de antemão que o byte E9 representa a letra 'é' na codificação ISO-8859-1, vamos usá-la aqui:</p>
                <pre><code>>>> characters.decode("latin1")
'cliché'
</code></pre>
                <p>Todo objeto <code>bytes</code> possui o método <code>decode</code> que interpreta (decodifica) os bytes em um sistema de codificação de caracteres passado como argumento. No caso, "latin-1" é um apelido para ISO-8859-1.</p>
                <p>Se usarmos outro sistema de codificação para interpretar os bytes, pode ser que os caracteres sejam interpretados de outra forma, ou que uma exceção seja lançada, caso não haja como interpretar algum caractere:</p>
                <pre><code>>>> characters.decode("cyrillic")
'clichщ'
>>> characters.decode("utf8")
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 5: unexpected end of data</code></pre>
                <p>Nesse exemplo, a codificação "cyrillic" (ISO-8859-5) interpreta o byte E9 como 'щ', já a codificação UTF-8 (Unicode) não possui um caractere válido para o byte E9, daí a exceção.</p>
            </div>
            <div id="converting-text-to-bytes">
                <h4>Convertendo texto para bytes</h4>
                <p>Converter de bytes para texto é decodificação. E converter de texto para bytes é codificação. Para codificar uma string em bytes, usamos o método <code>encode</code>.</p>
                <pre><code class="python-repl">>>> characters = "cliché"
>>> characters.encode("utf8")
b'clich\xc3\xa9'
>>> characters.encode("latin1")
b'clich\xe9'
>>> characters.encode("cp437")
b'clich\x82'
>>> characters.encode("ascii")
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)</code></pre>
            </div>
            <p>Observe que as codificações mais famosas usam o ASCII como um subconjunto, para compatibilidade. Mas começam a divergir para caracteres além do ASCII.</p>
            <p>Quando uma codificação não consegue representar um caractere, por padrão, é lançada uma exceção. Mas podemos mudar esse comportamento passando um segundo argumento ao método. As possibilidades para lidar com um caractere não reconhecido são:</p>
            <pre><code class="python-repl">>>> "cliché".encode("ascii", 'strict')
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 5: ordinal not in range(128)
>>> "cliché".encode("ascii", 'replace')
b'clich?'
>>> "cliché".encode("ascii", 'ignore')
b'clich'
>>> "cliché".encode("ascii", 'xmlcharrefreplace')
b'clich&amp;#233;'</code></pre>
            <p><i>strict</i> é a estratégia padrão, se não informada, e lança uma exceção. <i>replace</i> substitui caracteres não reconhecidos por interrogações. <i>ignore</i> omite caracteres não reconhecidos. E <i>xmlcharrefreplace</i> substitui o caractere não reconhecido pela sua entidade XML.</p>

            <p>É possível invocar os métodos <code>str.encode</code> e <code>bytes.decode</code> sem informar a codificação. Nesse caso, será usada a padrão do teu sistema operacional, que pode ser verificada com <code>sys.getedefaultencoding()</code>. Softwares modernos utilizam a codificação UTF-8, mas sistemas legados utilizavam miríades de codificações. Por isso, é um bom hábito explicitamente informar a codificação, para que seu programa continue funcionando adequadamente em qualquer plataforma.</p>
        </div>
        <div id="mutable-byte-strings">
            <h3>8.1.4 Strings de byte mutáveis</h3>
            <p>Objetos <code>str</code> e <code>bytes</code> são imutáveis. Para modificar esses objetos, na verdade instanciamos novos objetos<!-- (Removi essa parte pois não necessariamente é verdadeira, pois o Python possui otimizações para trabalhar com concatenação de strings), que é uma operação mais cara que simplesmente adicionar um item a uma lista, por exemplo. Isso pode ser incoveniente ao lidar com I/O, pois frequentemente é necessário fazer o buffer de bytes chegando ou saindo até que os dados estejam completos. Por exemplo, se estivermos recebendo dados de um socket, pode ser necessário invocar <code>recv</code> várias vezes antes de recebermos uma mensagem completa-->. Mas o Python também possui o objeto <code>bytearray</code>, que funciona como um <code>bytes</code> mas possui muitas das operações e métodos de uma lista. A propósito, tanto <code>bytes</code> quanto <code>bytearray</code> possuem muitos dos métodos também presentes em <code>str</code>, como <code>islower</code> ou <code>find</code>.</p>
            <pre><code class="python-repl">>>> b = bytearray(b"a\xe7\xe3o!")
>>> b.decode("latin1")
'ação!'
>>> b[1] = 110
>>> b.decode("latin1")
'anão!'
>>> b[2:4] = b"el"
>>> b.decode("latin1")
'anel!'
>>> b[4] = "o"
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'str' object cannot be interpreted as an integer
>>> b[4] = ord("o")
>>> b
bytearray(b'anelo')</code></pre>
            <p>Ao inicializar um <code>bytearray</code>, podemos passar caracteres ASCII normalmente, que serão mapeados para seus respectivos valores em bytes. Para outros caracteres, precisamos informar seu código numérico, por exemplo, usando a sequência de escape <code>\x</code>. A linha 4 modifica o byte do índice 1 para o valor 110, que em ASCII, é a letra 'n'. A linha 7 modifica uma sequência de bytes. Curiosamente, na linha 10, se tentar modificar apenas um índice passando uma string, dá erro. Se você não souber o código ASCII de determinado caractere, pode invocar a função <code>ord</code>, como na linha 14. Se tentar imprimir um objeto <code>bytes</code> ou <code>bytearray</code> sem decodificá-lo, caracteres além do ASCII não serão exibidos. Como na linha 15 não há mais caracteres além do ASCII, optei por imprimir o objeto sem decodificá-lo.</p>

            <p>Com essas três opções, pode ficar a dúvida de qual é a mais apropriada. Como um princípio fundamental de programação, a legibilidade e a facilidade de manuseio devem ser priorizadas. Assim, se estiver lidando com texto, a escolha mais natural seria usar o tipo <code>str</code>. Se por outro lado for trabalhar com arquivos binários, melhor começar com <code>bytes</code>. Se a mutabilidade de <code>bytearray</code> facilitar teu trabalho ou tornar teu código mais legível, então mude.</p>
        </div>
        <div id="exercicios">
            <h3>8.1.5 Exercícios</h3>
            <ol class="excs">
                <li class="no-mark">Implemente uma função para cada exercício.</li>
                <li>Receber uma string. Retorná-la de trás para frente.</li>
                <li>Dada uma string, ela é composta apenas por dígitos?</li>
                <li>Dada uma frase, quantas letras ela possui?</li>
                <li>Dada uma frase, quais são as iniciais de cada palavra?</li>
                <li>Receber uma string s e dois caracteres x e y. Substituir as ocorrências de x por y na string s. Retornar a string resultante.</li>
                <li>Receber uma frase. Retorná-la na notação CamelCase.</li>
                <li>Receber duas strings. Concatenar a segunda na primeira apenas se a primeira não terminar com a segunda string. Retornar a string resultante.</li>
                <li>Receber uma frase e retornar sua maior palavra.</li>
                <li>Receber uma string $s$ e dois índices $i$ e $j$. Remover os caracteres entre $i$ fechado e $j$ aberto. Retornar a string resultante. Exemplo de entrada/saída: "abcdefghij" 4 8/abcdij".</li>
                <li>Receber duas strings. Remover cada caractere na segunda string da primeira string. Exemplo de entrada/saída: "The quick brown fox jumps over the lazy dog." "aeiou"/"Th qck brwn fx jmps vr th lzy dg."</li>
                <li>Receber uma string $s$ e quatro índices $i$, $j$, $k$ e $l$. Trocar as substring $[i,j)$ e $[k,l)$. Retornar a string resultante. Exemplo de entrada/saída: abc<b>def</b>ghij<b>klmnop</b>qrstuvwxyz 3 6 10 16/abc<b>klmnop</b>ghij<b>def</b>qrstuvwxyz.</li>
                <li>Receber uma string $s$, um índice $i$ e outra string $r$. Adicionar a string $r$ no índice $i$ da string $s$. Retornar a string resultante.</li>
                <li>Receber uma string e retornar outra string formada pelos dois primeiros e dois últimos caracteres da string lida. Exemplos de entrada/saída: abcdef/abef, abcd/abcd, abc/abc, ab/ab, a/a.</li>
                <li>Receber uma string e retorná-la com as palavras invertidas. Exemplos de entrada/saída: "uma frase"/"frase uma", "programar é muito legal"/"legal muito é programar".</li>
                <li>Dadas duas strings, elas possuem a mesma sequência de vogais, desconsiderando outros caracteres? Por exemplo, litoral, e picotar possuem a mesma sequência de vogais "ioa".</li>
                <li>Dadas duas strings, quantas vezes uma está contida na outra? Exemplo, "ANA" ocorre 4 vezes em "ANA E MARIANA GOSTAM DE BANANA".</li>
                <li>Um palíndromo é uma sequência de caracteres que se lê da mesma forma que de trás para frente, como ARARA, REVIVER ou OGALOAMAOLAGO. Dada uma string, ela é palíndroma?.</li>
                <li>A Cifra de César é uma das técnicas de criptografia mais simples e conhecidas. Ela consiste em substituir cada letra de um texto pela n-ésima letra do alfabeto após ela, sendo n um número inteiro, chamado de chave de encriptação. Por exemplo, para n=5, o texto "Rex" se torna "Wjc". Dada a chave e o texto, qual o texto encriptado?</li>

            </ol>
        </div>
    </div>
</div>