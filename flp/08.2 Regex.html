<!DOCTYPE html>

<head>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
        }, false);
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script defer>hljs.configure({ cssSelector: "code", languages: ["python"] }); hljs.highlightAll(); hljs.initLineNumbersOnLoad();</script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body,{delimiters:[{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>

    <style>
        img {
            max-width: 90vw;
            max-height: 90vh;
        }

        .center {
            text-align: center;
        }

        .katex {
            /* o padrão é 1.21, vc pode remover essa configuração se quiser deixar o padrão */
            font-size: 1.0em;
        }

        table.custom,
        table.custom>thead>tr>th,
        table.custom>tbody>tr>td,
        table.custom>tbody>tr>th {
            /* tabela centralizada e com bordas */
            border: 1px solid black;
            border-collapse: collapse;
            margin-left: auto;
            margin-right: auto;
            padding-left: 5px;
            padding-right: 5px;
            text-align: center;
        }

        table pre {
            /* Remove a margem interna de tags pre dentro de tabelas */
            margin: 0;
            padding: 0;
            text-align: left;
        }

        td:has(pre) {
            /* tags pre dentro de tabela são alinhadas no topo à esquerda */
            vertical-align: top;
        }

        table.align-left th,
        table.align-left td {
            /* alinha à esquerda as células da tabela */
            text-align: left !important;
        }

        /* inicia a lista de exercícios */
        ol.excs {
            padding-inline-start: 0em;
            counter-reset: excs;
            list-style: none;
        }

        /* põe um numerador num item da lista de exercícios, desde que não seja da classe no-mark */
        ol.excs>li:not(.no-mark)::before {
            counter-increment: excs;
            content: counters(excs, ".") ". ";
        }

        /* põe uma barra vertical ao lado do item da lista de exercícios */
        ol.excs>li {
            /* Change this to adjust the line color and thickness */
            border-left: 2px solid #000;
            /* Optional: Add padding to create some space between the bar and content */
            padding-left: 10px;
            margin-block-start: 1em;
            margin-block-end: 1em;
        }

        ol.section {
            counter-reset: section;
            list-style-type: none;
        }

        ol.section li::before {
            counter-increment: section;
            content: counters(section, ".") ". ";
        }

        td.hljs-ln-numbers {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            color: #ccc;
            border-right: 1px solid #999;
            padding-right: 5px;
        }

        td.hljs-ln-code {
            /* estilizar as linhas de código da extensao highlightjs-line-numbers */
            padding-left: 10px;
        }

        .info {
            border-left: 6px solid blue;
            padding-left: 1%;
        }
    </style>
</head>

<div id="8-strings-and-serialization">
    <h1>8 Strings e serialização</h1>
    <div id="8-2-regular-expressions">
        <h2>8.2 Expressões regulares</h2>
        <div id="8-2-1-introducao">
            <h3>8.2.1 Introdução</h3>
            <p>Uma expressão regular (regex) é uma sequência de caracteres que define um padrão para busca de texto. Existem várias implementações de regex, conhecidas como engines. Assim como as principais linguagens de programação, o Python possui sua própria engine. Diferentes engines podem ter algumas nuances entre si, mas aprendendo regex em Python, talvez apenas algumas adaptações sejam necessárias ao aplicar na maioria das linguagens. A linguagem regex não é orientada a objetos, mas o Python oferece vários objetos para trabalhar com regex. O módulo <code>re</code> inclui diversas classes e funções para manipulação de regex. Vamos começar com a função <code>findall</code>:</p>

            <pre><code class="python-repl">>>> import re
>>> len(re.findall("e", "Python 3.10 was released on October 04, 2021"))
4
>>> re.findall("\\d", "Python 3.10 was released on October 04, 2021")
['3', '1', '0', '0', '4', '2', '0', '2', '1']
>>> re.findall(r"\d", "Python 3.10 was released on October 04, 2021")
['3', '1', '0', '0', '4', '2', '0', '2', '1']
>>> re.findall("\d", "Python 3.10 was released on October 04, 2021")  
&lt;stdin>:1: SyntaxWarning: invalid escape sequence '\d'
['3', '1', '0', '0', '4', '2', '0', '2', '1']
>>> re.findall(r"z", "Python 3.10 was released on October 04, 2021")  
[]</code></pre>
            <p>O primeiro argumento da função <code>findall</code> é o padrão de correspondência e o segundo argumento é a string de busca. O retorno é uma lista com as correspondências encontradas. Na primeira invocação, é buscada pela letra "e". Na segunda invocação é buscado por um dígito, que no regex, é representado pelo <b>caractere especial</b> <code>\d</code>. Como numa string a barra invertida é usada como sequência de escape, precisamos escapar a barra invertida, colocando outra barra invertida, para não interpretar <code>\d</code> como sequência de escape. Regex possui vários caracteres especiais para formar padrões de texto. Para não ter que ficar escapando cada barra invertida, o Python possui a string bruta, ou r-string, que automaticamente escapa qualquer barra invertida, sem a necessidade de pôr a segunda barra invertida, como na terceira invocação.
            <div class="info">Para ilustrar a diferença de string e r-string, veja como uma sequência de escape não é interpretada numa r-string:
                <pre><code class="python-repl">>>> print("Hello\nWorld\t!")  # Interpretando sequência de escape
Hello
World   !
>>> print("Hello\\nWorld\\t!")  # Escapando manualmente
Hello\nWorld\t!
>>> print(r"Hello\nWorld\t!")  # Escapando automaticamente
Hello\nWorld\t!</code></pre>
            </div>
            <p>Apesar da quarta invocação funcionar, é exibida uma mensagem de aviso, pois não escapamos a barra invertida. Isso funciona pois até a versão 3.12, que estou usando, sequências de escape inválidas não são interpretadas e a barra invertida é interpretada literalmente. Mas está previsto para <a href="https://docs.python.org/dev/whatsnew/3.12.html#other-language-changes">alguma próxima versão</a> tornar o aviso em exceção <code>SyntaxError</code> e esses códigos legados pararem de funcionar. Portanto, sempre que usar um caractere regex especial que contenha uma barra invertida, não se esqueça de adicionar uma segunda barra invertida ou usar r-string.</p>
            <p>As principais funções do módulo <code>re</code> são:</p>
            <table class="custom align-left">
                <thead>
                    <tr>
                        <td>Função</td>
                        <td>Descrição</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>match(pattern, string, flags=0)</code></td>
                        <td>Busca o padrão no início da string, retornando um objeto <code>Match</code>.</td>
                    </tr>
                    <tr>
                        <td><code>search(pattern, string, flags=0)</code></td>
                        <td>Busca a primeira ocorrência do padrão na string, retornando um objeto <code>Match</code>.</td>
                    </tr>
                    <tr>
                        <td><code>findall(pattern, string, flags=0)</code></td>
                        <td>Busca por todas as ocorrências do padrão na string, retornando uma lista de strings ou de tuplas, dependendo do caso.</td>
                    </tr>
                    <tr>
                        <td><code>finditer(pattern, string, flags=0)</code></td>
                        <td>Busca por todas as ocorrências do padrão na string, mas retorna um iterador de <code>Match</code>s.</td>
                    </tr>
                    <tr>
                        <td><code>sub(pattern, repl, string, count=0, flags=0)</code></td>
                        <td>Substitui todas as ocorrências do padrão na string por outra substring.</td>
                    </tr>
                    <tr>
                        <td><code>split(pattern, string, maxsplit=0, flags=0)</code></td>
                        <td>Divide a string em uma lista de strings que correspondam ao padrão.</td>
                    </tr>
                </tbody>
            </table>
            <p>O objeto <code>Match</code> possui informações sobre a busca. Veja a diferença entre <code>finditer</code>, que retorna um iterador de <code>Match</code>s e <code>finditer</code>, que aqui retorna uma lista de strings:</p>
            <table class="custom">
                <thead>
                    <tr>
                        <th>Código</th>
                        <th>Saída</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <pre><code>findall_result = re.findall("e", "Python 3.10 was released on October 04, 2021")
for result in findall_result:
    print(f"Encontrei '{result}'")
print("Primeiro resultado:", findall_result[0])</code></pre>
                        </td>
                        <td>
                            <pre>Encontrei 'e'
Encontrei 'e'
Encontrei 'e'
Encontrei 'e'
Primeiro resultado: e</pre>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <pre><code>finditer_result = re.finditer("e", "Python 3.10 was released on October 04, 2021")
for result in finditer_result:
    print(f"Encontrei '{result.group()}' entre {result.start()} e {result.end()}.")
print("Primeiro resultado:", finditer_result[0])</code></pre>
                        </td>
                        <td>
                            <pre>Encontrei 'e' entre 17 e 18.
Encontrei 'e' entre 19 e 20.
Encontrei 'e' entre 22 e 23.
Encontrei 'e' entre 33 e 34.
TypeError: 'callable_iterator' object is not subscriptable</pre>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Os principais métodos de <code>Match</code> são <code>group</code>, que retorna a string encontrada, <code>start</code> e <code>end</code>, que retornam, respectivamente, o início e o fim-1 onde encontrou a string.</p>
            <div class="info">
                <p>Um objeto iterador, como veremos no próximo capítulo, é considerado "lazy" porque os elementos são iterados sob demanda, ou seja, apenas quando solicitados. Isso significa que o iterador não gera todos os elementos imediatamente, o que pode economizar memória e processamento.</p>
                <p>Por outro lado, uma lista é considerada "eager" porque todos os seus elementos são gerados de uma vez, ocupando memória e processamento desde o início. Por isso que iteradores não possuem índices nem é possível invocar a função <code>len</code>, pois só sabemos a quantidade de elementos depois de ter percorrido toda a sequência.</p>
            </div>

            <p>Toda vez que você invoca essas funções, o Python "compila" o padrão de busca em uma estrutura interna para realizar a busca, o que leva tempo. Para maior eficiência, se um padrão for reutilizado diversas vezes, é melhor realizar essa compilação apenas uma vez com a função <code>compile</code>:</p>
            <pre><code>def search(pattern_string, string_list):
    pattern = re.compile(pattern_string)  # Compila o padrão de expressão regular uma vez fora do loop

    results = []
    for string in string_list:
        results.append(pattern.findall(string))  # aqui o padrão já está compilado
    return results</code></pre>
            <p>A função <code>compile</code> retorna um objeto <code>Pattern</code>, que possui o padrão regex compilado e métodos com os mesmos nomes das funções anteriores para realizar buscas utilizando o padrão compilado. Embora seja importante cuidar da eficiência, o compilador Python já oferece ferramentas para aprimorar códigos passíveis de melhoria. Ele identifica partes que poderiam ser reescritas de maneira mais eficiente, como no exemplo anterior, se não tivéssemos utilizado a função <code>compile</code>. O Python automaticamente compila um padrão e o armazena em <i>cache</i> para uso posterior, otimizando assim o desempenho.</p>
        </div>
        <div id="8-2-2-conjuntos-caracteres">
            <h3>8.2.2 Conjuntos de caracteres</h3>
            <p>Regex possui padrões para representar conjuntos de caracteres, também chamados de classes de caracteres. São eles:</p>

            <h4>
                <pre>[aeiou]  [a-z]</pre>
            </h4>
            <p>Corresponde a qualquer um dos caracteres dentro dos colchetes.</p>
            <pre><code class="python-repl">>>> re.findall("[aeiou]", "quais as vogais dessa frase?")
['u', 'a', 'i', 'a', 'o', 'a', 'i', 'e', 'a', 'a', 'e']</code></pre>
            <p>Se contiver um hífen entre dois caracteres, corresponde ao intervalo fechado de caracteres entre eles.</p>
            <pre><code class="python-repl">>>> re.findall("[j-o]", "letras entre 'j' e 'o' são essas...")
['l', 'n', 'j', 'o']</code></pre>
            <p>Você pode colocar vários conjuntos dentro dos colchetes.</p>
            <pre><code class="python-repl">>>> re.findall("[A-Z0-9]", "Só qUero as MaiÚsculas e os núm3r05.")
['S', 'U', 'M', '3', '0', '5']</code></pre>
            <p>Para corresponder ao hífen também, coloque-o no início ou final dos colchetes.</p>
            <pre><code class="python-repl">>>> re.findall("[aeiou0-9-]", "Hífen (-) e dígitos 0 e 8.")
['e', '-', 'e', 'i', 'o', '0', 'e', '8']</code></pre>
            <p>Na tabela Unicode, letras acentuadas têm códigos diferentes.</p>
            <pre><code class="python-repl">>>> re.findall("[À-ÖØ-öø-ÿ]", "àquele PÊSSEGO piauí pôde Müller")
['à', 'Ê', 'í', 'ô', 'ü']</code></pre>

            <h4>
                <pre>[^aeiou]  [^a-z]</pre>
            </h4>
            <p>Corresponde a qualquer caractere que não seja os que estão dentro dos colchetes.</p>
            <pre><code class="python-repl">>>> re.findall("[^aeiou ]", "Vogais aqui não")
['V', 'g', 's', 'q', 'n', 'ã']
>>> re.findall("[^0-9]", "35T3 P3QU3N0 T3XT0")
['T', ' ', 'P', 'Q', 'U', 'N', ' ', 'T', 'X', 'T']</code></pre>

            <p>Existem vários caracteres especiais em regex. Mas dentro dos colchetes, os únicos especiais são <code>-</code>, <code>^</code> e <code>\</code>. Para escapá-los, você também pode precedê-los com uma <code>\</code>.</p>
            <h4>
                <pre>.</pre>
            </h4>
            <p>Corresponde a qualquer caractere exceto quebra de linha.</p>
            <pre><code class="python-repl">>>> re.findall(".e", "Você me ligou naquela tarde vazia\ne me valeu o dia")
['me', 'ue', 'de', 'me', 'le']</code></pre>
            <p>O <code>.</code> dentro dos colchetes funciona como ponto literal. Exemplo que captura cada caractere seguido por uma pontuação:</p>
            <pre><code class="python-repl">>>> re.findall(r".[.,?!]", "Pare! Repita? Oras, bolas.")
['e!', 'a?', 's,', 's.']</code></pre>
            <p>Exemplo que captura vogais distantes por dois caracteres:</p>
            <pre><code class="python-repl">>>> re.findall(r"[aeiou]..[aeiou]", "Processando erros fatais.")
['essa', 'erro', 'atai']</code></pre>

            <h4>
                <pre>\d</pre>
            </h4>
            <p>Corresponde a qualquer dígito. Abreviação de <code>[0-9]</code>.</p>
            <pre><code class="python-repl">>>> re.findall(r"\d\d", "Dia de São Valentim: 14/2/270.")
['14', '27']</code></pre>

            <h4>
                <pre>\w</pre>
            </h4>
            <p>Corresponde a qualquer caractere alfanumérico (de qualquer idioma) ou sublinhado.</p>
            <pre><code class="python-repl">>>> "".join(re.findall(r"\w", "1 ação! 2_アクション? 3-дію."))
'1ação2_アクション3дію'</code></pre>

            <h4>\s</h4>
            <p>Corresponde a qualquer caractere de espaço em branco (<a href="https://docs.python.org/3.8/library/string.html?highlight=whitespace#string.whitespace">whitespace</a>).</p>
            <pre><code class="python-repl">>>> len(re.findall(r"\s","Quantos\nwhitespaces essa\tfrase\rpossui?"))
4</code></pre>

            <h4>
                <pre>\D  \W  \S</pre>
            </h4>
            <p>Se você colocar em maiúsculos, é a negação do significado em minúsculo. Isto é, <code>\D</code>, <code>\W</code> e <code>\S</code> correspondem, respectivamente, a qualquer caractere não-dígito, não alfanumérico nem sublinhado, não whitespace.</p>
            <pre><code class="python-repl">>>> re.sub(r"\D", "", "Só quero os números deste telefone: +55(67)3012-4567")
'556730124567'
>>> re.sub(r"\W", "", "Apenas L3TR45! Juntas, misturadas.")
'ApenasL3TR45Juntasmisturadas'
>>> len(re.findall(r"\S","Quantidade de caracteres,\ndesconsiderando whitespaces\n"))
49</code></pre>

            <h4>Sequências de escape</h4>
            <p>Se você quiser escapar um caractere especial, para tratá-lo literalmente, basta precedê-lo por uma barra invertida:</p>
            <pre><code class="python-repl">>>> re.findall("\d\.\d", "1.2, 3.4, 5.6 e, por fim, 7.8")
['1.2', '3.4', '5.6', '7.8']</code></pre>

            <p>Regex também interpreta sequências de escape. Portanto, uma string usada como padrão de busca é compilada duas vezes, uma pelo próprio Python e outra pela engine de regex do Python. Isso quer dizer que se você colocar a string <code>\\n</code> como padrão de busca, primeiramente o Python entenderá que é para escapar a barra invertida, tornando a string na barra invertida literal seguida pela letra n, que o regex ainda entenderá como uma quebra de linha.</p>
            <p>Considere cada <code>findall</code> seguinte. O primeiro argumento é um padrão regex, que é interpretado tanto pelo Python quanto pela engine regex, já o segundo argumento é interpretado apenas pelo Python.</p>
            <pre><code class="python-repl">>>> print("a\nb")
a
b
>>> print("a\\nb")
a\nb
>>> re.findall(r"a\nb", "a\nb")
['a\nb']
>>> re.findall("a\\nb", "a\nb")
['a\nb']
>>> re.findall("a\\nb", "a\\nb")
[]</code></pre>
            <p>Na linha 6, o Python interpreta o padrão <code>\n</code> como quebra de linha, por isso correspondeu à string de busca. Na linha 8, o Python interpreta o padrão <code>\\n</code> como <code>\</code> e <code>n</code>, que a engine também interpreta como quebra de linha, por isso da correspondência. Na linha 10, o padrão é o mesmo da linha 8, mas como a string de busca é interpretada apenas pelo Python, o <code>\\n</code> se torna <code>\</code> e <code>n</code>, que não corresponde à quebra de linha do padrão.</p>
            <p>Se por um lado o Python ainda permite sequências de escape inválidas, tratando a barra invertida literamente, por outro lado, a engine regex também permite caracteres especiais inválidos, mas descarta a barra invertida. Por exemplo, <code>\_</code> não é nem uma sequência de escape, nem um caractere especial regex. E tanto <code>\_</code> quanto <code>\\_</code> são interpretados pelo Python como <code>\_</code>, que por outro lado, é interpretado pela engine como <code>_</code> apenas. Já pelo Python, <code>\\\_</code> vira <code>\\_</code>, que, pela engine, vira <code>\_</code>.</p>
            <pre><code>import re
print("a\_b")                         # a\_b
print("a\\_b")                        # a\_b
print("a\\\_b")                       # a\\_b
print(re.findall("a\_b", "a_b"))      # ['a_b']
print(re.findall("a\\_b", "a_b"))     # ['a_b']
print(re.findall("a\_b", "a\_b"))     # []
print(re.findall("a\\_b", "a\\_b"))   # []
print(re.findall("a\\\_b", "a_b"))    # []
print(re.findall("a\\\_b", "a\_b"))   # ['a\\_b']
print(re.findall("a\\\_b", "a\\_b"))  # ['a\\_b']
print(re.findall("a\\\_b", "a\\\_b")) # []</code></pre>
            <div class="info">
                <p>Observação: Você pode estar se perguntando por que as linhas 10 e 11 imprimiram as strings como <code>a\_b</code> em vez de <code>a\_b</code>, conforme as linhas 2 e 3. Isso ocorre porque ao imprimir listas, as sequências de escape não são interpretadas.</p>
                <pre><code class="python-repl">>>> l = ["string normal", "sequências\nde\tescape"]
>>> print(l)
['string normal', 'sequências\nde\tescape']
>>> print(f"['{l[0]}', '{l[1]}']")
['string normal', 'sequências
de      escape']</code></pre>
            </div>
        </div>
        <div id="8-2-3-quantificadores">
            <h3>8.2.3 Quantificadores</h3>
            <p>Quantificadores indicam a quantidade de caracteres ou expressões a corresponder.</p>

            <h4>
                <pre>*</pre>
            </h4>
            <p>Corresponde ao seu predecessor zero ou mais vezes.</p>
            <pre><code class="python-repl">>>> re.findall(r"fo*", "foo bar. f b. fooooo barrrrr")
['foo', 'f', 'fooooo']
>>> re.findall(r"\d*\.\d*", "num1 = 123\nnum2 = 34.56\nnum3 = .7\nnum4 = 8.901")
['34.56', '.7', '8.901']</code></pre>

            <h4>
                <pre>*</pre>
            </h4>
            <p>Corresponde ao seu predecessor uma ou mais vezes.</p>
            <pre><code class="python-repl">>>> re.findall(r"fo+", "foo bar. f b. fooooo barrrrr")
['foo', 'fooooo']
>>> re.findall(r"\d+\.\d+", "num1 = 123\nnum2 = 34.56\nnum3 = .7\nnum4 = 8.901")
['34.56', '8.901']</code></pre>

            <h4>
                <pre>{n}</pre>
            </h4>
            <p>Corresponde ao seu predecessor exatamente <code>n</code> vezes.</p>
            <pre><code class="python-repl">>>> list(re.finditer(r"o{3}", "foobar, foooobar, foooooobar"))
[&lt;re.Match object; span=(9, 12), match='ooo'>, &lt;re.Match object; span=(19, 22), match='ooo'>, &lt;re.Match object; span=(22, 25), match='ooo'>]</code></pre>

            <h4>
                <pre>{n,}</pre>
            </h4>
            <p>Corresponde ao seu predecessor pelo menos <code>n</code> vezes.</p>
            <pre><code class="python-repl">>>> list(re.finditer(r"o{3,}", "foobar, foooobar, foooooobar"))
[&lt;re.Match object; span=(9, 13), match='oooo'>, &lt;re.Match object; span=(19, 25), match='oooooo'>]</code></pre>

            <h4>
                <pre>x{m,n}</pre>
            </h4>
            <p>Corresponde ao seu predecessor pelo menos <code>m</code> e no máximo <code>n</code> vezes, sendo <code>0 &le; m &lt; n</code>.</p>
            <pre><code class="python-repl">>>> re.findall(r"\d{3,5}", "Capturando entre 3 e 5 dígitos: 1 23 456 7890 12345 678901")
['456', '7890', '12345', '67890']</code></pre>
            <p>Observe que no exemplo anterior, apesar de <code>678901</code> ter 6 dígitos, seus 5 primeiros dígitos ainda foram capturados.</p>

            <h4>
                <pre>?</pre>
            </h4>
            <p>Corresponde ao seu predecessor zero ou uma vez.</p>
            <pre><code class="python-repl">>>> re.findall(r"vultu?osa", "Possui vultuosa quantidade de dinheiro. Precisa de uma mala vultosa para guardá-lo.")
['vultuosa', 'vultosa']</code></pre>

            <h4>
                <pre>*?  +?  ??  {n}?  {n,}?  {n,m}?  </pre>
            </h4>
            <p>Por padrão, os quantificadores são <i>greedy</i> (gulosos), isto é, eles</p>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>
            <pre><code class="python-repl"></code></pre>


            <!-- um bom exemplo de disjunção | é caminhos de arquivos somente com extensão de imagem, como png, jpg, svg. poderia fazer um regex que procura por caminhos de arquivos sem whitespace e que sejam imagens. -->
        </div>
        <div id="getting-information-from-regular-expressions">
            <h3>8.2.2 Obtendo informações de expressões regulares</h3>
            Instead of returning a list of match objects, as you would expect, it returns a list of matching strings, or tuples. Sometimes it's strings, sometimes it's tuples. It's not a very good API at all! As with all bad APIs, you'll have to memorize the differences and not rely on intuition. The type of the return value depends on the number of bracketed groups inside the regular expression: If there are no groups in the pattern, re.findall will return a list of strings, where each value is a complete substring from the source string that matches the pattern If there is exactly one group in the pattern, re.findall will return a list of strings where each value is the contents of that group If there are multiple groups in the pattern, re.findall will return a list of tuples where each tuple contains a value from a matching group, in order

            When you are designing function calls in your own Python libraries, try to make the function always return a consistent data structure. It is often good to design functions that can take arbitrary inputs and process them, but the return value should not switch from a single value to a list, or a list of values to a list of tuples depending on the input. Let re.findall be a lesson!

            The examples in the following interactive session will hopefully clarify the differences:
            >>> import re
            >>> re.findall('a.', 'abacadefagah')
            ['ab', 'ac', 'ad', 'ag', 'ah']
            >>> re.findall('a(.)', 'abacadefagah')
            ['b', 'c', 'd', 'g', 'h']
            >>> re.findall('(a)(.)', 'abacadefagah')
            [('a', 'b'), ('a', 'c'), ('a', 'd'), ('a', 'g'), ('a', 'h')]
            >>> re.findall('((a)(.))', 'abacadefagah')
            [('ab', 'a', 'b'), ('ac', 'a', 'c'), ('ad', 'a', 'd'), ('ag', 'a', g'), ('ah', 'a','h')]
        </div>

        <div id="conclusao">
            <h4>Conclusão</h4>
            (colocar com minhas próprias palavras) The key thing to understand is that regex is about knowing "what" you can do, not necessarily "how" to do it. 15 years regex experience, and I still have to look up rules in Google, and then use a regex tester. But, as long as you know what can be done, finding the how is trivial.
        </div>
        <div id="referencias">
            <h4>Referências</h4>
            Basicamente a aula foi extraída desses dois: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet https://www.pythontutorial.net/python-regex/

            Muito bom para treinar tuas habilidades regex: http://regextutorials.com/index.html

            Conteúdo detalhado sobre regex: https://www.regular-expressions.info/lookaround.html

            Bom para testar regex: https://regex101.com/
        </div>
    </div>
</div>

<!-- exercícios de regex
Is this string a valid URL?
What is the date and time of all warning messages in a log file?
Which users in /etc/passwd are in a given group?
What username and document were requested by the URL a visitor typed?
-->